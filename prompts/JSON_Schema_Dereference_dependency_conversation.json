{
  "runSettings": {
    "temperature": 0.65,
    "model": "models/gemini-2.0-pro-exp-02-05",
    "topP": 0.95,
    "topK": 64,
    "maxOutputTokens": 8192,
    "safetySettings": [{
      "category": "HARM_CATEGORY_HARASSMENT",
      "threshold": "BLOCK_ONLY_HIGH"
    }, {
      "category": "HARM_CATEGORY_HATE_SPEECH",
      "threshold": "BLOCK_ONLY_HIGH"
    }, {
      "category": "HARM_CATEGORY_SEXUALLY_EXPLICIT",
      "threshold": "BLOCK_ONLY_HIGH"
    }, {
      "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
      "threshold": "BLOCK_ONLY_HIGH"
    }, {
      "category": "HARM_CATEGORY_CIVIC_INTEGRITY",
      "threshold": "BLOCK_LOW_AND_ABOVE"
    }],
    "responseMimeType": "text/plain",
    "enableCodeExecution": false,
    "enableEnhancedCivicAnswers": true,
    "enableSearchAsATool": false,
    "enableBrowseAsATool": false,
    "enableAutoFunctionResponse": false
  },
  "systemInstruction": {
  },
  "chunkedPrompt": {
    "chunks": [{
      "text": "```\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: README.md\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n# JSON Schema $Ref Parser\n\n#### Parse, Resolve, and Dereference JSON Schema $ref pointers\n\n[![Build Status](https://github.com/APIDevTools/json-schema-ref-parser/workflows/CI-CD/badge.svg?branch\u003dmaster)](https://github.com/APIDevTools/json-schema-ref-parser/actions)\n[![Coverage Status](https://coveralls.io/repos/github/APIDevTools/json-schema-ref-parser/badge.svg?branch\u003dmaster)](https://coveralls.io/github/APIDevTools/json-schema-ref-parser)\n\n[![npm](https://img.shields.io/npm/v/@apidevtools/json-schema-ref-parser.svg)](https://www.npmjs.com/package/@apidevtools/json-schema-ref-parser)\n[![License](https://img.shields.io/npm/l/@apidevtools/json-schema-ref-parser.svg)](LICENSE)\n[![Buy us a tree](https://img.shields.io/badge/Treeware-%F0%9F%8C%B3-lightgreen)](https://plant.treeware.earth/APIDevTools/json-schema-ref-parser)\n\n## Installation\n\nInstall using [npm](https://docs.npmjs.com/about-npm/):\n\n```bash\nnpm install @apidevtools/json-schema-ref-parser\nyarn add @apidevtools/json-schema-ref-parser\nbun add @apidevtools/json-schema-ref-parser\n```\n\n## The Problem:\n\nYou\u0027ve got a JSON Schema with `$ref` pointers to other files and/or URLs. Maybe you know all the referenced files ahead\nof time. Maybe you don\u0027t. Maybe some are local files, and others are remote URLs. Maybe they are a mix of JSON and YAML\nformat. Maybe some of the files contain cross-references to each other.\n\n```json\n{\n  \"definitions\": {\n    \"person\": {\n      // references an external file\n      \"$ref\": \"schemas/people/Bruce-Wayne.json\"\n    },\n    \"place\": {\n      // references a sub-schema in an external file\n      \"$ref\": \"schemas/places.yaml#/definitions/Gotham-City\"\n    },\n    \"thing\": {\n      // references a URL\n      \"$ref\": \"http://wayne-enterprises.com/things/batmobile\"\n    },\n    \"color\": {\n      // references a value in an external file via an internal reference\n      \"$ref\": \"#/definitions/thing/properties/colors/black-as-the-night\"\n    }\n  }\n}\n```\n\n## The Solution:\n\nJSON Schema $Ref Parser is a full [JSON Reference](https://tools.ietf.org/html/draft-pbryan-zyp-json-ref-03)\nand [JSON Pointer](https://tools.ietf.org/html/rfc6901) implementation that crawls even the most\ncomplex [JSON Schemas](http://json-schema.org/latest/json-schema-core.html) and gives you simple, straightforward\nJavaScript objects.\n\n- Use **JSON** or **YAML** schemas \u0026mdash; or even a mix of both!\n- Supports `$ref` pointers to external files and URLs, as well\n  as [custom sources](https://apitools.dev/json-schema-ref-parser/docs/plugins/resolvers.html) such as databases\n- Can [bundle](https://apitools.dev/json-schema-ref-parser/docs/ref-parser.html#bundlepath-options-callback) multiple\n  files into a single schema that only has _internal_ `$ref` pointers\n- Can [dereference](https://apitools.dev/json-schema-ref-parser/docs/ref-parser.html#dereferencepath-options-callback)\n  your schema, producing a plain-old JavaScript object that\u0027s easy to work with\n- Supports [circular references](https://apitools.dev/json-schema-ref-parser/docs/#circular-refs), nested references,\n  back-references, and cross-references between files\n- Maintains object reference equality \u0026mdash; `$ref` pointers to the same value always resolve to the same object\n  instance\n- Compatible with Node LTS and beyond, and all major web browsers on Windows, Mac, and Linux\n\n## Example\n\n```javascript\nimport $RefParser from \"@apidevtools/json-schema-ref-parser\";\n\ntry {\n  await $RefParser.dereference(mySchema);\n  // note - by default, mySchema is modified in place, and the returned value is a reference to the same object\n  console.log(mySchema.definitions.person.properties.firstName);\n\n  // if you want to avoid modifying the original schema, you can disable the `mutateInputSchema` option\n  let clonedSchema \u003d await $RefParser.dereference(mySchema, { mutateInputSchema: false });\n  console.log(clonedSchema.definitions.person.properties.firstName);\n} catch (err) {\n  console.error(err);\n}\n```\n\nFor more detailed examples, please see the [API Documentation](https://apitools.dev/json-schema-ref-parser/docs/)\n\n## Polyfills\n\nIf you are using Node.js \u003c 18, you\u0027ll need a polyfill for `fetch`,\nlike [node-fetch](https://github.com/node-fetch/node-fetch):\n\n```javascript\nimport fetch from \"node-fetch\";\n\nglobalThis.fetch \u003d fetch;\n```\n\n## Browser support\n\nJSON Schema $Ref Parser supports recent versions of every major web browser. Older browsers may\nrequire [Babel](https://babeljs.io/) and/or [polyfills](https://babeljs.io/docs/en/next/babel-polyfill).\n\nTo use JSON Schema $Ref Parser in a browser, you\u0027ll need to use a bundling tool such\nas [Webpack](https://webpack.js.org/), [Rollup](https://rollupjs.org/), [Parcel](https://parceljs.org/),\nor [Browserify](http://browserify.org/). Some bundlers may require a bit of configuration, such as\nsetting `browser: true` in [rollup-plugin-resolve](https://github.com/rollup/rollup-plugin-node-resolve).\n\n#### Webpack 5\n\nWebpack 5 has dropped the default export of node core modules in favour of polyfills, you\u0027ll need to set them up\nyourself ( after npm-installing them )\nEdit your `webpack.config.js` :\n\n```js\nconfig.resolve.fallback \u003d {\n  path: require.resolve(\"path-browserify\"),\n  fs: require.resolve(\"browserify-fs\"),\n};\n\nconfig.plugins.push(\n  new webpack.ProvidePlugin({\n    Buffer: [\"buffer\", \"Buffer\"],\n  }),\n);\n```\n\n## API Documentation\n\nFull API documentation is available [right here](https://apitools.dev/json-schema-ref-parser/docs/)\n\n## Contributing\n\nI welcome any contributions, enhancements, and\nbug-fixes. [Open an issue](https://github.com/APIDevTools/json-schema-ref-parser/issues) on GitHub\nand [submit a pull request](https://github.com/APIDevTools/json-schema-ref-parser/pulls).\n\n#### Building/Testing\n\nTo build/test the project locally on your computer:\n\n1. **Clone this repo**\u003cbr\u003e\n   `git clone https://github.com/APIDevTools/json-schema-ref-parser.git`\n\n2. **Install dependencies**\u003cbr\u003e\n   `yarn install`\n\n3. **Run the tests**\u003cbr\u003e\n   `yarn test`\n\n## License\n\nJSON Schema $Ref Parser is 100% free and open-source, under the [MIT license](LICENSE). Use it however you want.\n\n## Thanks\n\nThanks to these awesome contributors for their major support of this open-source project.\n\n- [JonLuca De Caro](https://jonlu.ca)\n- [Phil Sturgeon](https://philsturgeon.com)\n- [Stoplight](https://stoplight.io/?utm_source\u003dgithub\u0026utm_medium\u003dreadme\u0026utm_campaign\u003djson_schema_ref_parser)\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: 404.md\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n---\nlayout: 404\n---\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: _config.yml\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nremote_theme: APIDevTools/gh-pages-theme\n\ntitle: JSON Schema $Ref Parser\nlogo: https://apitools.dev/img/logos/logo.png\n\nauthor:\n  twitter: APIDevTools\n\ngoogle_analytics: UA-68102273-2\n\ntwitter:\n  username: APIDevTools\n  card: summary\n\ndefaults:\n  - scope:\n      path: \"\"\n    values:\n      image: https://apitools.dev/img/logos/card.png\n  - scope:\n      path: \"test/specs/**/*\"\n    values:\n      sitemap: false\n\nplugins:\n  - jekyll-sitemap\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: package.json\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n{\n  \"name\": \"@apidevtools/json-schema-ref-parser\",\n  \"version\": \"0.0.0-dev\",\n  \"description\": \"Parse, Resolve, and Dereference JSON Schema $ref pointers\",\n  \"scripts\": {\n    \"prepublishOnly\": \"yarn build\",\n    \"lint\": \"eslint lib\",\n    \"build\": \"rimraf dist \u0026\u0026 tsc\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"prettier\": \"prettier --write \\\"**/*.+(js|jsx|ts|tsx|har||json|css|md)\\\"\",\n    \"test\": \"vitest --coverage\",\n    \"test:node\": \"yarn test\",\n    \"test:browser\": \"cross-env BROWSER\u003d\\\"true\\\" yarn test\",\n    \"test:update\": \"vitest -u\",\n    \"test:watch\": \"vitest -w\"\n  },\n  \"keywords\": [\n    \"json\",\n    \"schema\",\n    \"jsonschema\",\n    \"json-schema\",\n    \"json-pointer\",\n    \"$ref\",\n    \"dereference\",\n    \"resolve\"\n  ],\n  \"author\": {\n    \"name\": \"James Messinger\",\n    \"url\": \"https://jamesmessinger.com\"\n  },\n  \"contributors\": [\n    {\n      \"name\": \"Boris Cherny\",\n      \"email\": \"boris@performancejs.com\"\n    },\n    {\n      \"name\": \"Phil Sturgeon\",\n      \"email\": \"phil@apisyouwonthate.com\"\n    },\n    {\n      \"name\": \"Jakub Rożek\",\n      \"email\": \"jakub@stoplight.io\"\n    },\n    {\n      \"name\": \"JonLuca DeCaro\",\n      \"email\": \"apis@jonlu.ca\"\n    }\n  ],\n  \"homepage\": \"https://apitools.dev/json-schema-ref-parser/\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/APIDevTools/json-schema-ref-parser.git\"\n  },\n  \"license\": \"MIT\",\n  \"funding\": \"https://github.com/sponsors/philsturgeon\",\n  \"types\": \"dist/lib/index.d.ts\",\n  \"main\": \"dist/lib/index.js\",\n  \"browser\": {\n    \"fs\": false\n  },\n  \"engines\": {\n    \"node\": \"\u003e\u003d 16\"\n  },\n  \"files\": [\n    \"lib\",\n    \"dist\",\n    \"cjs\"\n  ],\n  \"devDependencies\": {\n    \"@eslint/compat\": \"^1.2.5\",\n    \"@eslint/js\": \"^9.18.0\",\n    \"@types/eslint\": \"^9.6.1\",\n    \"@types/js-yaml\": \"^4.0.9\",\n    \"@types/node\": \"^22\",\n    \"@typescript-eslint/eslint-plugin\": \"^8.21.0\",\n    \"@typescript-eslint/parser\": \"^8.21.0\",\n    \"@vitest/coverage-v8\": \"^3.0.4\",\n    \"cross-env\": \"^7.0.3\",\n    \"eslint\": \"^9.18.0\",\n    \"eslint-config-prettier\": \"^10.0.1\",\n    \"eslint-config-standard\": \"^17.1.0\",\n    \"eslint-plugin-import\": \"^2.31.0\",\n    \"eslint-plugin-prettier\": \"^5.2.3\",\n    \"eslint-plugin-promise\": \"^7.2.1\",\n    \"eslint-plugin-unused-imports\": \"^4.1.4\",\n    \"globals\": \"^15.14.0\",\n    \"jsdom\": \"^26.0.0\",\n    \"prettier\": \"^3.4.2\",\n    \"rimraf\": \"^6.0.1\",\n    \"typescript\": \"^5.7.3\",\n    \"typescript-eslint\": \"^8.21.0\",\n    \"vitest\": \"^3.0.4\"\n  },\n  \"dependencies\": {\n    \"@jsdevtools/ono\": \"^7.1.3\",\n    \"@types/json-schema\": \"^7.0.15\",\n    \"js-yaml\": \"^4.1.0\"\n  },\n  \"release\": {\n    \"branches\": [\n      \"main\"\n    ],\n    \"plugins\": [\n      \"@semantic-release/commit-analyzer\",\n      \"@semantic-release/release-notes-generator\",\n      \"@semantic-release/npm\",\n      \"@semantic-release/github\"\n    ]\n  },\n  \"packageManager\": \"yarn@4.2.2\"\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: .prettierignore\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\ncoverage\ndist\nnode_modules\ntest/__snapshots__\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: .prettierrc\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n{\n  \"printWidth\": 120,\n  \"arrowParens\": \"always\",\n  \"semi\": true,\n  \"tabWidth\": 2,\n  \"trailingComma\": \"all\"\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: .yarnrc.yml\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nnodeLinker: node-modules\n\nyarnPath: .yarn/releases/yarn-4.2.2.cjs\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: docs/README.md\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n# JSON Schema $Ref Parser API\n\n## Things to Know\n\n- [Class methods vs. Instance methods](#class-methods-vs-instance-methods)\n- [Callbacks vs. Promises](#callbacks-vs-promises)\n- [Circular references](#circular-refs)\n\n## Classes \u0026 Methods\n\n#### [The `$RefParser` class](ref-parser.md)\n\n- [`schema` property](ref-parser.md#schema)\n- [`$refs` property](ref-parser.md#refs)\n- [`dereference()` method](ref-parser.md#dereferenceschema-options-callback)\n- [`bundle()` method](ref-parser.md#bundleschema-options-callback)\n- [`parse()` method](ref-parser.md#parseschema-options-callback)\n- [`resolve()` method](ref-parser.md#resolveschema-options-callback)\n\n#### [The `$Refs` class](refs.md)\n\n- [`circular` property](refs.md#circular)\n- [`paths()` method](refs.md#pathstypes)\n- [`values()` method](refs.md#valuestypes)\n- [`exists()` method](refs.md#existsref)\n- [`get()` method](refs.md#getref-options)\n- [`set()` method](refs.md#setref-value-options)\n\n#### [The `Options` object](options.md)\n\n### Class methods vs. Instance methods\n\nAll of JSON Schema $Ref Parser\u0027s methods are available as static (class) methods, and as instance methods.  The static methods simply create a new [`$RefParser`](ref-parser.md) instance and then call the corresponding instance method. Thus, the following line...\n\n```javascript\n$RefParser.bundle(\"my-schema.json\");\n```\n\n... is the same as this:\n\n```javascript\nlet parser \u003d new $RefParser();\nparser.bundle(\"my-schema.json\");\n```\n\nThe difference is that in the second example you now have a reference to `parser`, which means you can access the results ([`parser.schema`](ref-parser.md#schema) and [`parser.$refs`](ref-parser.md#refs)) anytime you want, rather than just in the callback function.\n\n### Callbacks vs. Promises\n\nMany people prefer [Promise syntax](http://javascriptplayground.com/blog/2015/02/promises/) or `async`/`await` instead of callbacks. JSON Schema $Ref Parser allows you to use whichever one you prefer.\n\nIf you pass a callback function to any method, then the method will call the callback using the Node.js error-first convention. If you do _not_ pass a callback function, then the method will return a Promise.\n\nThe following two examples are equivalent:\n\n```javascript\n// Callback syntax\n$RefParser.dereference(mySchema, (err, api) \u003d\u003e {\n  if (err) {\n    // Error\n  } else {\n    // Success\n  }\n});\n```\n\n```javascript\ntry {\n  // async/await syntax\n  let api \u003d await $RefParser.dereference(mySchema);\n\n  // Success\n} catch (err) {\n  // Error\n}\n```\n\n### Circular $Refs\n\nJSON Schema files can contain [circular $ref pointers](https://gist.github.com/JamesMessinger/d18278935fc73e3a0ee1), and JSON Schema $Ref Parser fully supports them. Circular references can be resolved and dereferenced just like any other reference. However, if you intend to serialize the dereferenced schema as JSON, then you should be aware that [`JSON.stringify`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) does not support circular references by default, so you will need to [use a custom replacer function](https://stackoverflow.com/questions/11616630/json-stringify-avoid-typeerror-converting-circular-structure-to-json).\n\nYou can disable circular references by setting the [`dereference.circular`](options.md) option to `false`. Then, if a circular reference is found, a `ReferenceError` will be thrown.\n\nOr you can choose to just ignore circular references altogether by setting the [`dereference.circular`](options.md) option to `\"ignore\"`. In this case, all non-circular references will still be dereferenced as normal, but any circular references will remain in the schema.\n\nAnother option is to use the [`bundle`](ref-parser.md#bundleschema-options-callback) method rather than the [`dereference`](ref-parser.md#dereferenceschema-options-callback) method. Bundling does _not_ result in circular references, because it simply converts _external_ `$ref` pointers to _internal_ ones.\n\n```javascript\n\"person\": {\n    \"properties\": {\n        \"name\": {\n          \"type\": \"string\"\n        },\n        \"spouse\": {\n          \"type\": {\n            \"$ref\": \"#/person\"        // circular reference\n          }\n        }\n    }\n}\n```\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: docs/options.md\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n# Options\n\nAll [`$RefParser`](ref-parser.md) methods accept an optional `options` parameter, which you can use to customize how the JSON Schema is parsed, resolved, dereferenced, etc.\n\nIf you pass an options parameter, you _don\u0027t_ need to specify _every_ option. Any options you don\u0027t specify will use their default values.\n\n## Example\n\n```javascript\n$RefParser.dereference(\"my-schema.yaml\", {\n  continueOnError: true, // Don\u0027t throw on the first error\n  parse: {\n    json: false, // Disable the JSON parser\n    yaml: {\n      allowEmpty: false, // Don\u0027t allow empty YAML files\n    },\n    text: {\n      canParse: [\".txt\", \".html\"], // Parse .txt and .html files as plain text (strings)\n      encoding: \"utf16\", // Use UTF-16 encoding\n    },\n  },\n  resolve: {\n    file: false, // Don\u0027t resolve local file references\n    http: {\n      timeout: 2000, // 2 second timeout\n      withCredentials: true, // Include auth credentials when resolving HTTP references\n    },\n  },\n  dereference: {\n    circular: false, // Don\u0027t allow circular $refs\n    excludedPathMatcher: (\n      path, // Skip dereferencing content under any \u0027example\u0027 key\n    ) \u003d\u003e path.includes(\"/example/\"),\n    onCircular: (\n      path, // Callback invoked during circular $ref detection\n    ) \u003d\u003e console.log(path),\n    onDereference: (\n      path,\n      value, // Callback invoked during dereferencing\n    ) \u003d\u003e console.log(path, value),\n  },\n});\n```\n\n## `parse` Options\n\nThe `parse` options determine how different types of files will be parsed.\n\nJSON Schema $Ref Parser comes with built-in JSON, YAML, plain-text, and binary parsers, any of which you can configure or disable. You can also add [your own custom parsers](plugins/parsers.md) if you want.\n\n| Option(s)                                                                 | Type                                               | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |\n| :------------------------------------------------------------------------ | :------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `json`\u003cbr\u003e`yaml`\u003cbr\u003e`text`\u003cbr\u003e`binary`                                    | `object` `boolean`                                 | These are the built-in parsers. In addition, you can add [your own custom parsers](plugins/parsers.md)\u003cbr\u003e\u003cbr\u003eTo disable a parser, just set it to `false`.                                                                                                                                                                                                                                                                                                                                                   |\n| `json.order` `yaml.order` `text.order` `binary.order`                     | `number`                                           | Parsers run in a specific order, relative to other parsers. For example, a parser with `order: 5` will run _before_ a parser with `order: 10`. If a parser is unable to successfully parse a file, then the next parser is tried, until one succeeds or they all fail.\u003cbr\u003e\u003cbr\u003eYou can change the order in which parsers run, which is useful if you know that most of your referenced files will be a certain type, or if you add [your own custom parser](plugins/parsers.md) that you want to run _first_. |\n| `json.allowEmpty` `yaml.allowEmpty` `text.allowEmpty` `binary.allowEmpty` | `boolean`                                          | All of the built-in parsers allow empty files by default. The JSON and YAML parsers will parse empty files as `undefined`. The text parser will parse empty files as an empty string. The binary parser will parse empty files as an empty byte array.\u003cbr\u003e\u003cbr\u003eYou can set `allowEmpty: false` on any parser, which will cause an error to be thrown if a file empty.                                                                                                                                         |\n| `json.canParse` `yaml.canParse` `text.canParse` `binary.canParse`         | `boolean`, `RegExp`, `string`, `array`, `function` | Determines which parsers will be used for which files.\u003cbr\u003e\u003cbr\u003eA regular expression can be used to match files by their full path. A string (or array of strings) can be used to match files by their file extension. Or a function can be used to perform more complex matching logic. See the [custom parser](plugins/parsers.md) docs for details.                                                                                                                                                         |\n| `text.encoding`                                                           | `string`                                           | The encoding to use when parsing text-based files. The default is \"utf8\".                                                                                                                                                                                                                                                                                                                                                                                                                                    |\n\n## `resolve` Options\n\nThe `resolve` options control how JSON Schema $Ref Parser will resolve file paths and URLs, and how those files will be read/downloaded.\n\nJSON Schema $Ref Parser comes with built-in support for HTTP and HTTPS, as well as support for local files (when running in Node.js). You can configure or disable either of these built-in resolvers. You can also add [your own custom resolvers](plugins/resolvers.md) if you want.\n\n| Option(s)                     | Type                                               | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n| :---------------------------- | :------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `external`                    | `boolean`                                          | Determines whether external $ref pointers will be resolved. If this option is disabled, then external $ref pointers will simply be ignored.                                                                                                                                                                                                                                                                                                                                                                                     |\n| `file`\u003cbr\u003e`http`              | `object` `boolean`                                 | These are the built-in resolvers. In addition, you can add [your own custom resolvers](plugins/resolvers.md)\u003cbr\u003e\u003cbr\u003eTo disable a resolver, just set it to `false`.                                                                                                                                                                                                                                                                                                                                                              |\n| `file.order` `http.order`     | `number`                                           | Resolvers run in a specific order, relative to other resolvers. For example, a resolver with `order: 5` will run _before_ a resolver with `order: 10`. If a resolver is unable to successfully resolve a path, then the next resolver is tried, until one succeeds or they all fail.\u003cbr\u003e\u003cbr\u003eYou can change the order in which resolvers run, which is useful if you know that most of your file references will be a certain type, or if you add [your own custom resolver](plugins/resolvers.md) that you want to run _first_. |\n| `file.canRead` `http.canRead` | `boolean`, `RegExp`, `string`, `array`, `function` | Determines which resolvers will be used for which files.\u003cbr\u003e\u003cbr\u003eA regular expression can be used to match files by their full path. A string (or array of strings) can be used to match files by their file extension. Or a function can be used to perform more complex matching logic. See the [custom resolver](plugins/resolvers.md) docs for details.                                                                                                                                                                      |\n| `http.headers`                | `object`                                           | You can specify any HTTP headers that should be sent when downloading files. For example, some servers may require you to set the `Accept` or `Referrer` header.                                                                                                                                                                                                                                                                                                                                                                |\n| `http.timeout`                | `number`                                           | The amount of time (in milliseconds) to wait for a response from the server when downloading files. The default is 60 seconds.                                                                                                                                                                                                                                                                                                                                                                                                   |\n| `http.redirects`              | `number`                                           | The maximum number of HTTP redirects to follow per file. The default is 5. To disable automatic following of redirects, set this to zero.                                                                                                                                                                                                                                                                                                                                                                                       |\n| `http.withCredentials`        | `boolean`                                          | Set this to `true` if you\u0027re downloading files from a CORS-enabled server that requires authentication                                                                                                                                                                                                                                                                                                                                                                                                                          |\n\n## `dereference` Options\n\nThe `dereference` options control how JSON Schema $Ref Parser will dereference `$ref` pointers within the JSON schema.\n\n| Option(s)             | Type                                                                   | Description                                                                                                                                                                                                                                                                                                                                                                                     |\n| :-------------------- | :--------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `circular`            | `boolean` or `\"ignore\"`                                                | Determines whether [circular `$ref` pointers](README.md#circular-refs) are handled.\u003cbr\u003e\u003cbr\u003eIf set to `false`, then a `ReferenceError` will be thrown if the schema contains any circular references.\u003cbr\u003e\u003cbr\u003e If set to `\"ignore\"`, then circular references will simply be ignored. No error will be thrown, but the [`$Refs.circular`](refs.md#circular) property will still be set to `true`. |\n| `excludedPathMatcher` | `(string) \u003d\u003e boolean`                                                  | A function, called for each path, which can return true to stop this path and all subpaths from being dereferenced further. This is useful in schemas where some subpaths contain literal `$ref` keys that should not be dereferenced.                                                                                                                                                          |\n| `onCircular`          | `(string) \u003d\u003e void`                                                     | A function, called immediately after detecting a circular `$ref` with the circular `$ref` in question.                                                                                                                                                                                                                                                                                          |\n| `onDereference`       | `(string, JSONSchemaObjectType, JSONSchemaObjectType, string) \u003d\u003e void` | A function, called immediately after dereferencing, with: the resolved JSON Schema value, the `$ref` being dereferenced, the object holding the dereferenced prop, the dereferenced prop name.                                                                                                                                                                                                  |\n| `preservedProperties` | `string[]`                                                             | An array of properties to preserve when dereferencing a `$ref` schema. Useful if you want to enforce non-standard dereferencing behavior like present in the OpenAPI 3.1 specification where `description` and `summary` properties are preserved when alongside a `$ref` pointer.                                                                                                              |\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: docs/ref-parser.md\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n# The $RefParser class\n\nThis is the default export of JSON Schema $Ref Parser. You can creates instances of this class using `new $RefParser()`, or you can just call its [static methods](README.md#class-methods-vs-instance-methods).\n\n##### Properties\n\n- [`schema`](#schema)\n- [`$refs`](#refs)\n\n##### Methods\n\n- [`dereference()`](#dereferenceschema-options-callback)\n- [`bundle()`](#bundleschema-options-callback)\n- [`parse()`](#parseschema-options-callback)\n- [`resolve()`](#resolveschema-options-callback)\n\n### `schema`\n\nThe `schema` property is the parsed/bundled/dereferenced JSON Schema object. This is the same value that is passed to the callback function (or Promise) when calling the [`parse`](#parseschema-options-callback), [`bundle`](#bundleschema-options-callback), or [`dereference`](#dereferenceschema-options-callback) methods.\n\n```javascript\nlet parser \u003d new $RefParser();\n\nparser.schema; // \u003d\u003e null\n\nlet schema \u003d await parser.dereference(\"my-schema.json\");\ntypeof parser.schema; // \u003d\u003e \"object\"\n\nschema \u003d\u003d\u003d parser.schema; // \u003d\u003e true\n```\n\n### `$refs`\n\nThe `$refs` property is a [`$Refs`](refs.md) object, which lets you access all of the externally-referenced files in the schema, as well as easily get and set specific values in the schema using JSON pointers.\n\nThis is the same value that is passed to the callback function (or Promise) when calling the [`resolve`](#resolveschema-options-callback) method.\n\n```javascript\nlet parser \u003d new $RefParser();\n\nparser.$refs.paths(); // \u003d\u003e [] empty array\n\nawait parser.dereference(\"my-schema.json\");\nparser.$refs.paths(); // \u003d\u003e [\"my-schema.json\"]\n```\n\n### `dereference(schema, [options], [callback])`\n\n- **schema** (_required_) - `string` or `object`\u003cbr\u003e\n  A JSON Schema object, or the file path or URL of a JSON Schema file. See the [`parse`](#parseschema-options-callback) method for more info.\n\n- **options** (_optional_) - `object`\u003cbr\u003e\n  See [options](options.md) for the full list of options\n\n- **callback** (_optional_) - `function(err, schema)`\u003cbr\u003e\n  A callback that will receive the dereferenced schema object\n\n- **Return Value:** `Promise`\u003cbr\u003e\n  See [Callbacks vs. Promises](README.md#callbacks-vs-promises)\n\nDereferences all `$ref` pointers in the JSON Schema, replacing each reference with its resolved value. This results in a schema object that does not contain _any_ `$ref` pointers. Instead, it\u0027s a normal JavaScript object tree that can easily be crawled and used just like any other JavaScript object. This is great for programmatic usage, especially when using tools that don\u0027t understand JSON references.\n\nThe `dereference` method maintains object reference equality, meaning that all `$ref` pointers that point to the same object will be replaced with references to the same object. Again, this is great for programmatic usage, but it does introduce the risk of [circular references](README.md#circular-refs), so be careful if you intend to serialize the schema using [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify). Consider using the [`bundle`](#bundleschema-options-callback) method instead, which does not create circular references.\n\n```javascript\nlet schema \u003d await $RefParser.dereference(\"my-schema.yaml\");\n\n// The `schema` object is a normal JavaScript object,\n// so you can easily access any part of the schema using simple dot notation\nconsole.log(schema.definitions.person.properties.firstName); // \u003d\u003e {type: \"string\"}\n\n// Object reference equality works as expected\nschema.definitions.thing \u003d\u003d\u003d schema.definitions.batmobile; // \u003d\u003e true\n```\n\n### `bundle(schema, [options], [callback])`\n\n- **schema** (_required_) - `string` or `object`\u003cbr\u003e\n  A JSON Schema object, or the file path or URL of a JSON Schema file. See the [`parse`](#parseschema-options-callback) method for more info.\n\n- **options** (_optional_) - `object`\u003cbr\u003e\n  See [options](options.md) for the full list of options\n\n- **callback** (_optional_) - `function(err, schema)`\u003cbr\u003e\n  A callback that will receive the bundled schema object\n\n- **Return Value:** `Promise`\u003cbr\u003e\n  See [Callbacks vs. Promises](README.md#callbacks-vs-promises)\n\nBundles all referenced files/URLs into a single schema that only has _internal_ `$ref` pointers. This lets you split-up your schema however you want while you\u0027re building it, but easily combine all those files together when it\u0027s time to package or distribute the schema to other people. The resulting schema size will be small, since it will still contain _internal_ JSON references rather than being [fully-dereferenced](#dereferenceschema-options-callback).\n\nThis also eliminates the risk of [circular references](README.md#circular-refs), so the schema can be safely serialized using [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify).\n\n```javascript\nlet schema \u003d await $RefParser.bundle(\"my-schema.yaml\");\nconsole.log(schema.definitions.person); // \u003d\u003e {$ref: \"#/definitions/schemas~1people~1Bruce-Wayne.json\"}\n```\n\n### `parse(schema, [options], [callback])`\n\n- **schema** (_required_) - `string` or `object`\u003cbr\u003e\n  A JSON Schema object, or the file path or URL of a JSON Schema file.\n  \u003cbr\u003e\u003cbr\u003e\n  The path can be absolute or relative. In Node, the path is relative to `process.cwd()`. In the browser, it\u0027s relative to the URL of the page.\n\n- **options** (_optional_) - `object`\u003cbr\u003e\n  See [options](options.md) for the full list of options\n\n- **callback** (_optional_) - `function(err, schema)`\u003cbr\u003e\n  A callback that will receive the parsed schema object, or an error\n\n- **Return Value:** `Promise`\u003cbr\u003e\n  See [Callbacks vs. Promises](README.md#callbacks-vs-promises)\n\n\u003e This method is used internally by other methods, such as [`bundle`](#bundleschema-options-callback) and [`dereference`](#dereferenceschema-options-callback). You probably won\u0027t need to call this method yourself.\n\nParses the given JSON Schema file (in JSON or YAML format), and returns it as a JavaScript object. This method **does not** resolve `$ref` pointers or dereference anything. It simply parses _one_ file and returns it.\n\n```javascript\nlet schema \u003d await $RefParser.parse(\"my-schema.yaml\");\nconsole.log(schema.definitions.person); // \u003d\u003e {$ref: \"schemas/people/Bruce-Wayne.json\"}\n```\n\n### `resolve(schema, [options], [callback])`\n\n- **path** (_required_) - `string` or `object`\u003cbr\u003e\n  A JSON Schema object, or the file path or URL of a JSON Schema file. See the [`parse`](#parseschema-options-callback) method for more info.\n\n- **options** (_optional_) - `object`\u003cbr\u003e\n  See [options](options.md) for the full list of options\n\n- **callback** (_optional_) - `function(err, $refs)`\u003cbr\u003e\n  A callback that will receive a [`$Refs`](refs.md) object\n\n- **Return Value:** `Promise`\u003cbr\u003e\n  See [Callbacks vs. Promises](README.md#callbacks-vs-promises)\n\n\u003e This method is used internally by other methods, such as [`bundle`](#bundleschema-options-callback) and [`dereference`](#dereferenceschema-options-callback). You probably won\u0027t need to call this method yourself.\n\nResolves all JSON references (`$ref` pointers) in the given JSON Schema file. If it references any other files/URLs, then they will be downloaded and resolved as well. This method **does not** dereference anything. It simply gives you a [`$Refs`](refs.md) object, which is a map of all the resolved references and their values.\n\n```javascript\nlet $refs \u003d await $RefParser.resolve(\"my-schema.yaml\");\n\n// $refs.paths() returns the paths of all the files in your schema\nlet filePaths \u003d $refs.paths();\n\n// $refs.get() lets you query parts of your schema\nlet name \u003d $refs.get(\"schemas/people/Bruce-Wayne.json#/properties/name\");\n\n// $refs.set() lets you change parts of your schema\n$refs.set(\"schemas/people/Bruce-Wayne.json#/properties/favoriteColor/default\", \"black\");\n```\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: docs/refs.md\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n# The $Refs class\n\nWhen you call the [`resolve`](ref-parser.md#resolveschema-options-callback) method, the value that gets passed to the callback function (or Promise) is a `$Refs` object. This same object is accessible via the [`parser.$refs`](ref-parser.md#refs) property of `$RefParser` objects.\n\nThis object is a map of JSON References and their resolved values. It also has several convenient helper methods that make it easy for you to navigate and manipulate the JSON References.\n\n##### Properties\n\n- [`circular`](#circular)\n\n##### Methods\n\n- [`paths()`](#pathstypes)\n- [`values()`](#valuestypes)\n- [`exists()`](#existsref)\n- [`get()`](#getref)\n- [`set()`](#setref-value)\n\n### `circular`\n\n- **Type:** `boolean`\n\nThis property is `true` if the schema contains any [circular references](README.md#circular-refs). You may want to check this property before serializing the dereferenced schema as JSON, since [`JSON.stringify()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify) does not support circular references by default.\n\n```javascript\nlet parser \u003d new $RefParser();\nawait parser.dereference(\"my-schema.json\");\n\nif (parser.$refs.circular) {\n  console.log(\"The schema contains circular references\");\n}\n```\n\n### `paths([types])`\n\n- **types** (_optional_) - `string` (one or more)\u003cbr\u003e\n  Optionally only return certain types of paths (\"file\", \"http\", etc.)\n\n- **Return Value:** `array` of `string`\u003cbr\u003e\n  Returns the paths/URLs of all the files in your schema (including the main schema file).\n\n```javascript\nlet $refs \u003d await $RefParser.resolve(\"my-schema.json\");\n\n// Get the paths of ALL files in the schema\n$refs.paths();\n\n// Get the paths of local files only\n$refs.paths(\"file\");\n\n// Get all URLs\n$refs.paths(\"http\");\n```\n\n### `values([types])`\n\n- **types** (_optional_) - `string` (one or more)\u003cbr\u003e\n  Optionally only return values from certain locations (\"file\", \"http\", etc.)\n\n- **Return Value:** `object`\u003cbr\u003e\n  Returns a map of paths/URLs and their correspond values.\n\n```javascript\nlet $refs \u003d await $RefParser.resolve(\"my-schema.json\");\n\n// Get ALL paths \u0026 values in the schema\n// (this is the same as $refs.toJSON())\nlet values \u003d $refs.values();\n\nvalues[\"schemas/people/Bruce-Wayne.json\"];\nvalues[\"schemas/places.yaml\"];\nvalues[\"http://wayne-enterprises.com/things/batmobile\"];\n```\n\n### `exists($ref)`\n\n- **$ref** (_required_) - `string`\u003cbr\u003e\n  The JSON Reference path, optionally with a JSON Pointer in the hash\n\n- **Return Value:** `boolean`\u003cbr\u003e\n  Returns `true` if the given path exists in the schema; otherwise, returns `false`\n\n```javascript\nlet $refs \u003d await $RefParser.resolve(\"my-schema.json\");\n\n$refs.exists(\"schemas/places.yaml#/definitions/Gotham-City\"); // \u003d\u003e true\n$refs.exists(\"schemas/places.yaml#/definitions/Metropolis\"); // \u003d\u003e false\n```\n\n### `get($ref)`\n\n- **$ref** (_required_) - `string`\u003cbr\u003e\n  The JSON Reference path, optionally with a JSON Pointer in the hash\n\n- **Return Value:** `boolean`\u003cbr\u003e\n  Gets the value at the given path in the schema. Throws an error if the path does not exist.\n\n```javascript\nlet $refs \u003d await $RefParser.resolve(\"my-schema.json\");\nlet value \u003d $refs.get(\"schemas/people/Bruce-Wayne.json#/properties/address\");\n```\n\n### `set($ref, value)`\n\n- **$ref** (_required_) - `string`\u003cbr\u003e\n  The JSON Reference path, optionally with a JSON Pointer in the hash\n\n- **value** (_required_)\u003cbr\u003e\n  The value to assign. Can be anything (object, string, number, etc.)\n\nSets the value at the given path in the schema. If the property, or any of its parents, don\u0027t exist, they will be created.\n\n```javascript\nlet $refs \u003d await $RefParser.resolve(\"my-schema.json\");\n$refs.set(\"schemas/people/Bruce-Wayne.json#/properties/favoriteColor/default\", \"black\");\n```\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: docs/plugins/file-info-object.md\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n# File Info Object\n\nJSON Schema $Ref Parser supports plug-ins, such as [resolvers](resolvers.md) and [parsers](parsers.md). These plug-ins can have methods such as `canRead()`, `read()`, `canParse()`, and `parse()`. All of these methods accept the same object as their parameter: an object containing information about the file being read or parsed.\n\nThe file info object currently only consists of a few properties, but it may grow in the future if plug-ins end up needing more information.\n\n| Property    | Type                                                                       | Description                                                                                                                                                                             |\n| :---------- | :------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `url`       | `string`                                                                   | The full URL of the file. This could be any type of URL, including \"http://\", \"https://\", \"file://\", \"ftp://\", \"mongodb://\", or even a local filesystem path (when running in Node.js). |\n| `extension` | `string`                                                                   | The lowercase file extension, such as \".json\", \".yaml\", \".txt\", etc.                                                                                                                    |\n| `data`      | `string` [`Buffer`](https://nodejs.org/api/buffer.html#buffer_buffer) etc. | The raw file contents, in whatever form they were returned by the [resolver](resolvers.md) that read the file.                                                                          |\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: docs/plugins/parsers.md\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n# Custom Parsers\n\nJSON Schema $Ref Parser comes with built-in JSON, YAML, plain-text, and binary parsers, but you can add your own parsers to support additional file types, or even replace any of the built-in parsers with your own custom implementation.\n\nYou can see the source code for any of the built-in parsers [right here](../../lib/parsers).\n\n#### Simple Example: Creating your own parser\n\nThe fastest way to learn is by example, so let\u0027s do that. Here\u0027s a simplistic parser that parses CSV files (comma-separated values):\n\n```javascript\nlet myParser \u003d {\n  order: 1,\n\n  canParse: \".csv\",\n\n  parse(file) {\n    let lines \u003d file.data.toString().split(\"\\n\");\n    return lines.map((line) \u003d\u003e {\n      return line.split(\",\");\n    });\n  },\n};\n\n$RefParser.dereference(mySchema, { parse: { csv: myParser } });\n```\n\n#### The `order` property\n\nAll parsers have an `order` property, even the built-in parsers. If you don\u0027t specify an `order` property, then your parser will run last. Specifying `order: 1`, like we did in this example, will make your parser run first. Or you can squeeze your parser in-between some of the built-in parsers. For example, `order: 201` would make it run _after_ the JSON and YAML parsers, but _before_ the plain-text and binary parsers. You can see the order of all the built-in parsers by looking at [their source code](../../lib/parsers).\n\nThe `order` property and `canParse` property are related to each other. For each file that JSON Schema $Ref Parser needs to parse, it first determines which parsers _can_ parse that file by checking their `canParse` property. If only one parser matches a file, then _only_ that one parser is called, regardless of its `order`. If multiple parsers match a file, then those parsers are tried _in order_ until one of them successfully parses the file. Once a parser successfully parses the file, the rest of the parsers are skipped.\n\nIf _none_ of the parsers match the file, then _all_ of them are tried, in order, until one of them successfuly parses the file, or until they all fail. This is useful for situations where a file _is_ a supported type, but it has an unrecognized file extension.\n\n#### The `canParse` property\n\nThe `canParse` property tells JSON Schema $Ref Parser what kind of files your parser can handle. In this example, we\u0027ve simply specified a file extension, but we could have used a simple boolean, an array of file extensions, a regular expression, or even a function with custom logic to determine which files to parse. Here are examples of each approach:\n\n```javascript\nlet myParser \u003d {\n  // Parse ALL file types\n  canParse: true\n\n  // An array of file extensions (lowercased)\n  canParse: [\".txt\", \".csv\"]\n\n  // A regular expression (matched against the FULL file path)\n  canParse: /\\.(txt|csv)$/i\n\n  // A function that returns a truthy/falsy value\n  canParse(file) {\n    return file.extension \u003d\u003d\u003d \".csv\" || file.extension \u003d\u003d\u003d \".txt\";\n  }\n};\n```\n\nWhen using the function form, the `file` parameter is a [file info object](file-info-object.md), which contains information about the file being parsed.\n\n#### The `parse` method\n\nObviously, this is where the real work of a parser happens. The `parse` method accepts the same [file info object](file-info-object.md) as the `canParse` function, but rather than returning a boolean value, the `parse` method should return a JavaScript representation of the file contents. For our CSV parser, that is a two-dimensional array of lines and values. For your parser, it might be an object, a string, a custom class, or anything else.\n\nUnlike the `canParse` function, the `parse` method can also be asynchronous. This might be important if your parser needs to retrieve data from a database or if it relies on an external HTTP service to return the parsed value. You can return your asynchronous value via a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or a Node.js-style error-first callback. Here are examples of both approaches:\n\n```javascript\nlet myCallbackParser \u003d {\n  // Return the value in a callback function\n  parse(file, callback) {\n    doSomethingAsync(file.data, (data) \u003d\u003e {\n      if (data) {\n        // Success !\n        callback(null, data);\n      } else {\n        // Error !\n        callback(new Error(\"No data!\"));\n      }\n    });\n  },\n};\n\nlet myPromiseParser \u003d {\n  // Return the value in an ES6 Promise\n  async parse(file) {\n    let data \u003d await doSomethingAsync(file.data);\n\n    if (data) {\n      // Success !\n      return data;\n    } else {\n      // Error !\n      throw new Error(\"No data!\");\n    }\n  },\n};\n```\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: docs/plugins/resolvers.md\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n# Custom Resolvers\n\nJSON Schema $Ref Parser comes with built-in resolvers for HTTP and HTTPS URLs, as well as local filesystem paths (when running in Node.js). You can add your own custom resolvers to support additional protocols, or even replace any of the built-in resolvers with your own custom implementation.\n\nYou can see the source code for any of the built-in resolvers [right here](../../lib/resolvers).\n\n#### Simple Example: Creating your own resolver\n\nThe fastest way to learn is by example, so let\u0027s do that. Here\u0027s a simplistic resolver that reads data from a MongoDB database:\n\n```javascript\nlet myResolver \u003d {\n  order: 1,\n\n  canRead: /^mongodb:/i,\n\n  read(file, callback, $refs) {\n    MongoClient.connect(file.url, (err, db) \u003d\u003e {\n      if (err) {\n        callback(err);\n      }\n      else {\n        db.find({}).toArray((err, document) \u003d\u003e {\n          callback(null, document);\n        });\n      }\n    }\n  }\n};\n\n$RefParser.dereference(mySchema, { resolve: { mongo: myResolver }});\n```\n\n#### The `order` property\n\nAll resolvers have an `order` property, even the built-in resolvers. If you don\u0027t specify an `order` property, then your resolver will run last. Specifying `order: 1`, like we did in this example, will make your resolver run first. Or you can squeeze your resolver in-between some of the built-in resolvers. For example, `order: 101` would make it run _after_ the file resolver, but _before_ the HTTP resolver. You can see the order of all the built-in resolvers by looking at [their source code](../../lib/resolvers).\n\nThe `order` property and `canRead` property are related to each other. For each file that JSON Schema $Ref Parser needs to resolve, it first determines which resolvers _can_ read that file by checking their `canRead` property. If only one resolver matches a file, then _only_ that one resolver is called, regardless of its `order`. If multiple resolvers match a file, then those resolvers are tried _in order_ until one of them successfully reads the file. Once a resolver successfully reads the file, the rest of the resolvers are skipped.\n\n#### The `canRead` property\n\nThe `canRead` property tells JSON Schema $Ref Parser what kind of files your resolver can read. In this example, we\u0027ve simply specified a regular expression that matches \"mogodb://\" URLs, but we could have used a simple boolean, or even a function with custom logic to determine which files to resolve. Here are examples of each approach:\n\n```javascript\nlet myResolver \u003d {\n  // Read ALL files\n  canRead: true\n\n  // Read all files on localhost\n  canRead: /localhost/i\n\n  // A function that returns a truthy/falsy value\n  canRead(file) {\n    return file.url.indexOf(\"127.0.0.1\") !\u003d\u003d -1;\n  }\n};\n```\n\nWhen using the function form, the `file` parameter is a [file info object](file-info-object.md), which contains information about the file being resolved. The `$refs` parameter is a [`$Refs`](../refs.md) object, which allows your resolver to determine context (ex. `$refs._root$Ref.path` can be used to determine the relative path your resolver is operating from).\n\n#### The `read` method\n\nThis is where the real work of a resolver happens. The `read` method accepts the same [file info object](file-info-object.md) as the `canRead` function, but rather than returning a boolean value, the `read` method should return the contents of the file. The file contents should be returned in as raw a form as possible, such as a string or a byte array. Any further parsing or processing should be done by [parsers](parsers.md).\n\nUnlike the `canRead` function, the `read` method can also be asynchronous. This might be important if your resolver needs to read data from a database or some other external source. You can return your asynchronous value via a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or a Node.js-style error-first callback. Of course, if your resolver has the ability to return its data synchronously, then that\u0027s fine too. Here are examples of all three approaches:\n\n```javascript\nlet myCallbackResolver \u003d {\n  // Return the value synchronously\n  read(file) {\n    return fs.readFileSync(file.url);\n  }\n\n  // Return the value in a callback function\n  read(file, callback) {\n    doSomethingAsync(file.url, (data) \u003d\u003e {\n      if (data) {\n        // Success !\n        callback(null, data);\n      }\n      else {\n        // Error !\n        callback(new Error(\"No data!\"));\n      }\n    });\n  }\n};\n\nlet myPromiseResolver \u003d {\n  // Return the value in an ES6 Promise\n  async read(file) {\n    let data \u003d await doSomethingAsync(file.url);\n\n    if (data) {\n      // Success !\n      return data;\n    }\n    else {\n      // Error !\n      throw new Error(\"No data!\");\n    }\n  }\n};\n```\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/bundle.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport $Ref from \"./ref.js\";\nimport Pointer from \"./pointer.js\";\nimport * as url from \"./util/url.js\";\nimport type $Refs from \"./refs.js\";\nimport type $RefParser from \"./index\";\nimport type { ParserOptions } from \"./index\";\nimport type { JSONSchema } from \"./index\";\n\nexport interface InventoryEntry {\n  $ref: any;\n  parent: any;\n  key: any;\n  pathFromRoot: any;\n  depth: any;\n  file: any;\n  hash: any;\n  value: any;\n  circular: any;\n  extended: any;\n  external: any;\n  indirections: any;\n}\n/**\n * Bundles all external JSON references into the main JSON schema, thus resulting in a schema that\n * only has *internal* references, not any *external* references.\n * This method mutates the JSON schema object, adding new references and re-mapping existing ones.\n *\n * @param parser\n * @param options\n */\nfunction bundle\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  parser: $RefParser\u003cS, O\u003e,\n  options: O,\n) {\n  // console.log(\u0027Bundling $ref pointers in %s\u0027, parser.$refs._root$Ref.path);\n\n  // Build an inventory of all $ref pointers in the JSON Schema\n  const inventory: InventoryEntry[] \u003d [];\n  crawl\u003cS, O\u003e(parser, \"schema\", parser.$refs._root$Ref.path + \"#\", \"#\", 0, inventory, parser.$refs, options);\n\n  // Remap all $ref pointers\n  remap(inventory);\n}\n\n/**\n * Recursively crawls the given value, and inventories all JSON references.\n *\n * @param parent - The object containing the value to crawl. If the value is not an object or array, it will be ignored.\n * @param key - The property key of `parent` to be crawled\n * @param path - The full path of the property being crawled, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of the property being crawled, from the schema root\n * @param indirections\n * @param inventory - An array of already-inventoried $ref pointers\n * @param $refs\n * @param options\n */\nfunction crawl\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  parent: object | $RefParser\u003cS, O\u003e,\n  key: string | null,\n  path: string,\n  pathFromRoot: string,\n  indirections: number,\n  inventory: InventoryEntry[],\n  $refs: $Refs\u003cS, O\u003e,\n  options: O,\n) {\n  const obj \u003d key \u003d\u003d\u003d null ? parent : parent[key as keyof typeof parent];\n\n  if (obj \u0026\u0026 typeof obj \u003d\u003d\u003d \"object\" \u0026\u0026 !ArrayBuffer.isView(obj)) {\n    if ($Ref.isAllowed$Ref(obj)) {\n      inventory$Ref(parent, key, path, pathFromRoot, indirections, inventory, $refs, options);\n    } else {\n      // Crawl the object in a specific order that\u0027s optimized for bundling.\n      // This is important because it determines how `pathFromRoot` gets built,\n      // which later determines which keys get dereferenced and which ones get remapped\n      const keys \u003d Object.keys(obj).sort((a, b) \u003d\u003e {\n        // Most people will expect references to be bundled into the the \"definitions\" property,\n        // so we always crawl that property first, if it exists.\n        if (a \u003d\u003d\u003d \"definitions\") {\n          return -1;\n        } else if (b \u003d\u003d\u003d \"definitions\") {\n          return 1;\n        } else {\n          // Otherwise, crawl the keys based on their length.\n          // This produces the shortest possible bundled references\n          return a.length - b.length;\n        }\n      }) as (keyof typeof obj)[];\n\n      for (const key of keys) {\n        const keyPath \u003d Pointer.join(path, key);\n        const keyPathFromRoot \u003d Pointer.join(pathFromRoot, key);\n        const value \u003d obj[key];\n\n        if ($Ref.isAllowed$Ref(value)) {\n          inventory$Ref(obj, key, path, keyPathFromRoot, indirections, inventory, $refs, options);\n        } else {\n          crawl(obj, key, keyPath, keyPathFromRoot, indirections, inventory, $refs, options);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Inventories the given JSON Reference (i.e. records detailed information about it so we can\n * optimize all $refs in the schema), and then crawls the resolved value.\n *\n * @param $refParent - The object that contains a JSON Reference as one of its keys\n * @param $refKey - The key in `$refParent` that is a JSON Reference\n * @param path - The full path of the JSON Reference at `$refKey`, possibly with a JSON Pointer in the hash\n * @param indirections - unknown\n * @param pathFromRoot - The path of the JSON Reference at `$refKey`, from the schema root\n * @param inventory - An array of already-inventoried $ref pointers\n * @param $refs\n * @param options\n */\nfunction inventory$Ref\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  $refParent: any,\n  $refKey: string | null,\n  path: string,\n  pathFromRoot: string,\n  indirections: number,\n  inventory: InventoryEntry[],\n  $refs: $Refs\u003cS, O\u003e,\n  options: O,\n) {\n  const $ref \u003d $refKey \u003d\u003d\u003d null ? $refParent : $refParent[$refKey];\n  const $refPath \u003d url.resolve(path, $ref.$ref);\n  const pointer \u003d $refs._resolve($refPath, pathFromRoot, options);\n  if (pointer \u003d\u003d\u003d null) {\n    return;\n  }\n  const parsed \u003d Pointer.parse(pathFromRoot);\n  const depth \u003d parsed.length;\n  const file \u003d url.stripHash(pointer.path);\n  const hash \u003d url.getHash(pointer.path);\n  const external \u003d file !\u003d\u003d $refs._root$Ref.path;\n  const extended \u003d $Ref.isExtended$Ref($ref);\n  indirections +\u003d pointer.indirections;\n\n  const existingEntry \u003d findInInventory(inventory, $refParent, $refKey);\n  if (existingEntry) {\n    // This $Ref has already been inventoried, so we don\u0027t need to process it again\n    if (depth \u003c existingEntry.depth || indirections \u003c existingEntry.indirections) {\n      removeFromInventory(inventory, existingEntry);\n    } else {\n      return;\n    }\n  }\n\n  inventory.push({\n    $ref, // The JSON Reference (e.g. {$ref: string})\n    parent: $refParent, // The object that contains this $ref pointer\n    key: $refKey, // The key in `parent` that is the $ref pointer\n    pathFromRoot, // The path to the $ref pointer, from the JSON Schema root\n    depth, // How far from the JSON Schema root is this $ref pointer?\n    file, // The file that the $ref pointer resolves to\n    hash, // The hash within `file` that the $ref pointer resolves to\n    value: pointer.value, // The resolved value of the $ref pointer\n    circular: pointer.circular, // Is this $ref pointer DIRECTLY circular? (i.e. it references itself)\n    extended, // Does this $ref extend its resolved value? (i.e. it has extra properties, in addition to \"$ref\")\n    external, // Does this $ref pointer point to a file other than the main JSON Schema file?\n    indirections, // The number of indirect references that were traversed to resolve the value\n  });\n\n  // Recursively crawl the resolved value\n  if (!existingEntry || external) {\n    crawl(pointer.value, null, pointer.path, pathFromRoot, indirections + 1, inventory, $refs, options);\n  }\n}\n\n/**\n * Re-maps every $ref pointer, so that they\u0027re all relative to the root of the JSON Schema.\n * Each referenced value is dereferenced EXACTLY ONCE.  All subsequent references to the same\n * value are re-mapped to point to the first reference.\n *\n * @example: {\n *    first: { $ref: somefile.json#/some/part },\n *    second: { $ref: somefile.json#/another/part },\n *    third: { $ref: somefile.json },\n *    fourth: { $ref: somefile.json#/some/part/sub/part }\n *  }\n *\n * In this example, there are four references to the same file, but since the third reference points\n * to the ENTIRE file, that\u0027s the only one we need to dereference.  The other three can just be\n * remapped to point inside the third one.\n *\n * On the other hand, if the third reference DIDN\u0027T exist, then the first and second would both need\n * to be dereferenced, since they point to different parts of the file. The fourth reference does NOT\n * need to be dereferenced, because it can be remapped to point inside the first one.\n *\n * @param inventory\n */\nfunction remap(inventory: InventoryEntry[]) {\n  // Group \u0026 sort all the $ref pointers, so they\u0027re in the order that we need to dereference/remap them\n  inventory.sort((a: InventoryEntry, b: InventoryEntry) \u003d\u003e {\n    if (a.file !\u003d\u003d b.file) {\n      // Group all the $refs that point to the same file\n      return a.file \u003c b.file ? -1 : +1;\n    } else if (a.hash !\u003d\u003d b.hash) {\n      // Group all the $refs that point to the same part of the file\n      return a.hash \u003c b.hash ? -1 : +1;\n    } else if (a.circular !\u003d\u003d b.circular) {\n      // If the $ref points to itself, then sort it higher than other $refs that point to this $ref\n      return a.circular ? -1 : +1;\n    } else if (a.extended !\u003d\u003d b.extended) {\n      // If the $ref extends the resolved value, then sort it lower than other $refs that don\u0027t extend the value\n      return a.extended ? +1 : -1;\n    } else if (a.indirections !\u003d\u003d b.indirections) {\n      // Sort direct references higher than indirect references\n      return a.indirections - b.indirections;\n    } else if (a.depth !\u003d\u003d b.depth) {\n      // Sort $refs by how close they are to the JSON Schema root\n      return a.depth - b.depth;\n    } else {\n      // Determine how far each $ref is from the \"definitions\" property.\n      // Most people will expect references to be bundled into the the \"definitions\" property if possible.\n      const aDefinitionsIndex \u003d a.pathFromRoot.lastIndexOf(\"/definitions\");\n      const bDefinitionsIndex \u003d b.pathFromRoot.lastIndexOf(\"/definitions\");\n\n      if (aDefinitionsIndex !\u003d\u003d bDefinitionsIndex) {\n        // Give higher priority to the $ref that\u0027s closer to the \"definitions\" property\n        return bDefinitionsIndex - aDefinitionsIndex;\n      } else {\n        // All else is equal, so use the shorter path, which will produce the shortest possible reference\n        return a.pathFromRoot.length - b.pathFromRoot.length;\n      }\n    }\n  });\n\n  let file, hash, pathFromRoot;\n  for (const entry of inventory) {\n    // console.log(\u0027Re-mapping $ref pointer \"%s\" at %s\u0027, entry.$ref.$ref, entry.pathFromRoot);\n\n    if (!entry.external) {\n      // This $ref already resolves to the main JSON Schema file\n      entry.$ref.$ref \u003d entry.hash;\n    } else if (entry.file \u003d\u003d\u003d file \u0026\u0026 entry.hash \u003d\u003d\u003d hash) {\n      // This $ref points to the same value as the prevous $ref, so remap it to the same path\n      entry.$ref.$ref \u003d pathFromRoot;\n    } else if (entry.file \u003d\u003d\u003d file \u0026\u0026 entry.hash.indexOf(hash + \"/\") \u003d\u003d\u003d 0) {\n      // This $ref points to a sub-value of the prevous $ref, so remap it beneath that path\n      entry.$ref.$ref \u003d Pointer.join(pathFromRoot, Pointer.parse(entry.hash.replace(hash, \"#\")));\n    } else {\n      // We\u0027ve moved to a new file or new hash\n      file \u003d entry.file;\n      hash \u003d entry.hash;\n      pathFromRoot \u003d entry.pathFromRoot;\n\n      // This is the first $ref to point to this value, so dereference the value.\n      // Any other $refs that point to the same value will point to this $ref instead\n      entry.$ref \u003d entry.parent[entry.key] \u003d $Ref.dereference(entry.$ref, entry.value);\n\n      if (entry.circular) {\n        // This $ref points to itself\n        entry.$ref.$ref \u003d entry.pathFromRoot;\n      }\n    }\n  }\n\n  // we want to ensure that any $refs that point to another $ref are remapped to point to the final value\n  // let hadChange \u003d true;\n  // while (hadChange) {\n  //   hadChange \u003d false;\n  //   for (const entry of inventory) {\n  //     if (entry.$ref \u0026\u0026 typeof entry.$ref \u003d\u003d\u003d \"object\" \u0026\u0026 \"$ref\" in entry.$ref) {\n  //       const resolved \u003d inventory.find((e: InventoryEntry) \u003d\u003e e.pathFromRoot \u003d\u003d\u003d entry.$ref.$ref);\n  //       if (resolved) {\n  //         const resolvedPointsToAnotherRef \u003d\n  //           resolved.$ref \u0026\u0026 typeof resolved.$ref \u003d\u003d\u003d \"object\" \u0026\u0026 \"$ref\" in resolved.$ref;\n  //         if (resolvedPointsToAnotherRef \u0026\u0026 entry.$ref.$ref !\u003d\u003d resolved.$ref.$ref) {\n  //           // console.log(\u0027Re-mapping $ref pointer \"%s\" at %s\u0027, entry.$ref.$ref, entry.pathFromRoot);\n  //           entry.$ref.$ref \u003d resolved.$ref.$ref;\n  //           hadChange \u003d true;\n  //         }\n  //       }\n  //     }\n  //   }\n  // }\n}\n\n/**\n * TODO\n */\nfunction findInInventory(inventory: InventoryEntry[], $refParent: any, $refKey: any) {\n  for (const existingEntry of inventory) {\n    if (existingEntry \u0026\u0026 existingEntry.parent \u003d\u003d\u003d $refParent \u0026\u0026 existingEntry.key \u003d\u003d\u003d $refKey) {\n      return existingEntry;\n    }\n  }\n  return undefined;\n}\n\nfunction removeFromInventory(inventory: InventoryEntry[], entry: any) {\n  const index \u003d inventory.indexOf(entry);\n  inventory.splice(index, 1);\n}\nexport default bundle;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/dereference.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport $Ref from \"./ref.js\";\nimport Pointer from \"./pointer.js\";\nimport { ono } from \"@jsdevtools/ono\";\nimport * as url from \"./util/url.js\";\nimport type $Refs from \"./refs.js\";\nimport type { DereferenceOptions, ParserOptions } from \"./options.js\";\nimport type { JSONSchema } from \"./types\";\nimport type $RefParser from \"./index\";\nimport { TimeoutError } from \"./util/errors\";\n\nexport default dereference;\n\n/**\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\n *\n * @param parser\n * @param options\n */\nfunction dereference\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  parser: $RefParser\u003cS, O\u003e,\n  options: O,\n) {\n  const start \u003d Date.now();\n  // console.log(\u0027Dereferencing $ref pointers in %s\u0027, parser.$refs._root$Ref.path);\n  const dereferenced \u003d crawl\u003cS, O\u003e(\n    parser.schema,\n    parser.$refs._root$Ref.path!,\n    \"#\",\n    new Set(),\n    new Set(),\n    new Map(),\n    parser.$refs,\n    options,\n    start,\n  );\n  parser.$refs.circular \u003d dereferenced.circular;\n  parser.schema \u003d dereferenced.value;\n}\n\n/**\n * Recursively crawls the given value, and dereferences any JSON references.\n *\n * @param obj - The value to crawl. If it\u0027s not an object or array, it will be ignored.\n * @param path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of `obj` from the schema root\n * @param parents - An array of the parent objects that have already been dereferenced\n * @param processedObjects - An array of all the objects that have already been processed\n * @param dereferencedCache - An map of all the dereferenced objects\n * @param $refs\n * @param options\n * @param startTime - The time when the dereferencing started\n * @returns\n */\nfunction crawl\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  obj: any,\n  path: string,\n  pathFromRoot: string,\n  parents: Set\u003cany\u003e,\n  processedObjects: Set\u003cany\u003e,\n  dereferencedCache: any,\n  $refs: $Refs\u003cS, O\u003e,\n  options: O,\n  startTime: number,\n) {\n  let dereferenced;\n  const result \u003d {\n    value: obj,\n    circular: false,\n  };\n\n  if (options \u0026\u0026 options.timeoutMs) {\n    if (Date.now() - startTime \u003e options.timeoutMs) {\n      throw new TimeoutError(options.timeoutMs);\n    }\n  }\n  const derefOptions \u003d (options.dereference || {}) as DereferenceOptions;\n  const isExcludedPath \u003d derefOptions.excludedPathMatcher || (() \u003d\u003e false);\n\n  if (derefOptions?.circular \u003d\u003d\u003d \"ignore\" || !processedObjects.has(obj)) {\n    if (obj \u0026\u0026 typeof obj \u003d\u003d\u003d \"object\" \u0026\u0026 !ArrayBuffer.isView(obj) \u0026\u0026 !isExcludedPath(pathFromRoot)) {\n      parents.add(obj);\n      processedObjects.add(obj);\n\n      if ($Ref.isAllowed$Ref(obj, options)) {\n        dereferenced \u003d dereference$Ref(\n          obj,\n          path,\n          pathFromRoot,\n          parents,\n          processedObjects,\n          dereferencedCache,\n          $refs,\n          options,\n          startTime,\n        );\n        result.circular \u003d dereferenced.circular;\n        result.value \u003d dereferenced.value;\n      } else {\n        for (const key of Object.keys(obj)) {\n          const keyPath \u003d Pointer.join(path, key);\n          const keyPathFromRoot \u003d Pointer.join(pathFromRoot, key);\n\n          if (isExcludedPath(keyPathFromRoot)) {\n            continue;\n          }\n\n          const value \u003d obj[key];\n          let circular \u003d false;\n\n          if ($Ref.isAllowed$Ref(value, options)) {\n            dereferenced \u003d dereference$Ref(\n              value,\n              keyPath,\n              keyPathFromRoot,\n              parents,\n              processedObjects,\n              dereferencedCache,\n              $refs,\n              options,\n              startTime,\n            );\n            circular \u003d dereferenced.circular;\n            // Avoid pointless mutations; breaks frozen objects to no profit\n            if (obj[key] !\u003d\u003d dereferenced.value) {\n              // If we have properties we want to preserve from our dereferenced schema then we need\n              // to copy them over to our new object.\n              const preserved: Map\u003cstring, unknown\u003e \u003d new Map();\n              if (derefOptions?.preservedProperties) {\n                if (typeof obj[key] \u003d\u003d\u003d \"object\" \u0026\u0026 !Array.isArray(obj[key])) {\n                  derefOptions?.preservedProperties.forEach((prop) \u003d\u003e {\n                    if (prop in obj[key]) {\n                      preserved.set(prop, obj[key][prop]);\n                    }\n                  });\n                }\n              }\n\n              obj[key] \u003d dereferenced.value;\n\n              // If we have data to preserve and our dereferenced object is still an object then\n              // we need copy back our preserved data into our dereferenced schema.\n              if (derefOptions?.preservedProperties) {\n                if (preserved.size \u0026\u0026 typeof obj[key] \u003d\u003d\u003d \"object\" \u0026\u0026 !Array.isArray(obj[key])) {\n                  preserved.forEach((value, prop) \u003d\u003e {\n                    obj[key][prop] \u003d value;\n                  });\n                }\n              }\n\n              derefOptions?.onDereference?.(value.$ref, obj[key], obj, key);\n            }\n          } else {\n            if (!parents.has(value)) {\n              dereferenced \u003d crawl(\n                value,\n                keyPath,\n                keyPathFromRoot,\n                parents,\n                processedObjects,\n                dereferencedCache,\n                $refs,\n                options,\n                startTime,\n              );\n              circular \u003d dereferenced.circular;\n              // Avoid pointless mutations; breaks frozen objects to no profit\n              if (obj[key] !\u003d\u003d dereferenced.value) {\n                obj[key] \u003d dereferenced.value;\n              }\n            } else {\n              circular \u003d foundCircularReference(keyPath, $refs, options);\n            }\n          }\n\n          // Set the \"isCircular\" flag if this or any other property is circular\n          result.circular \u003d result.circular || circular;\n        }\n      }\n\n      parents.delete(obj);\n    }\n  }\n\n  return result;\n}\n\n/**\n * Dereferences the given JSON Reference, and then crawls the resulting value.\n *\n * @param $ref - The JSON Reference to resolve\n * @param path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param pathFromRoot - The path of `$ref` from the schema root\n * @param parents - An array of the parent objects that have already been dereferenced\n * @param processedObjects - An array of all the objects that have already been dereferenced\n * @param dereferencedCache - An map of all the dereferenced objects\n * @param $refs\n * @param options\n * @returns\n */\nfunction dereference$Ref\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  $ref: any,\n  path: string,\n  pathFromRoot: string,\n  parents: Set\u003cany\u003e,\n  processedObjects: any,\n  dereferencedCache: any,\n  $refs: $Refs\u003cS, O\u003e,\n  options: O,\n  startTime: number,\n) {\n  const isExternalRef \u003d $Ref.isExternal$Ref($ref);\n  const shouldResolveOnCwd \u003d isExternalRef \u0026\u0026 options?.dereference?.externalReferenceResolution \u003d\u003d\u003d \"root\";\n  const $refPath \u003d url.resolve(shouldResolveOnCwd ? url.cwd() : path, $ref.$ref);\n\n  const cache \u003d dereferencedCache.get($refPath);\n  if (cache \u0026\u0026 !cache.circular) {\n    const refKeys \u003d Object.keys($ref);\n    if (refKeys.length \u003e 1) {\n      const extraKeys \u003d {};\n      for (const key of refKeys) {\n        if (key !\u003d\u003d \"$ref\" \u0026\u0026 !(key in cache.value)) {\n          // @ts-expect-error TS(7053): Element implicitly has an \u0027any\u0027 type because expre... Remove this comment to see the full error message\n          extraKeys[key] \u003d $ref[key];\n        }\n      }\n      return {\n        circular: cache.circular,\n        value: Object.assign({}, cache.value, extraKeys),\n      };\n    }\n\n    return cache;\n  }\n\n  const pointer \u003d $refs._resolve($refPath, path, options);\n\n  if (pointer \u003d\u003d\u003d null) {\n    return {\n      circular: false,\n      value: null,\n    };\n  }\n\n  // Check for circular references\n  const directCircular \u003d pointer.circular;\n  let circular \u003d directCircular || parents.has(pointer.value);\n  if (circular) {\n    foundCircularReference(path, $refs, options);\n  }\n\n  // Dereference the JSON reference\n  let dereferencedValue \u003d $Ref.dereference($ref, pointer.value);\n\n  // Crawl the dereferenced value (unless it\u0027s circular)\n  if (!circular) {\n    // Determine if the dereferenced value is circular\n    const dereferenced \u003d crawl(\n      dereferencedValue,\n      pointer.path,\n      pathFromRoot,\n      parents,\n      processedObjects,\n      dereferencedCache,\n      $refs,\n      options,\n      startTime,\n    );\n    circular \u003d dereferenced.circular;\n    dereferencedValue \u003d dereferenced.value;\n  }\n\n  if (circular \u0026\u0026 !directCircular \u0026\u0026 options.dereference?.circular \u003d\u003d\u003d \"ignore\") {\n    // The user has chosen to \"ignore\" circular references, so don\u0027t change the value\n    dereferencedValue \u003d $ref;\n  }\n\n  if (directCircular) {\n    // The pointer is a DIRECT circular reference (i.e. it references itself).\n    // So replace the $ref path with the absolute path from the JSON Schema root\n    dereferencedValue.$ref \u003d pathFromRoot;\n  }\n\n  const dereferencedObject \u003d {\n    circular,\n    value: dereferencedValue,\n  };\n\n  // only cache if no extra properties than $ref\n  if (Object.keys($ref).length \u003d\u003d\u003d 1) {\n    dereferencedCache.set($refPath, dereferencedObject);\n  }\n\n  return dereferencedObject;\n}\n\n/**\n * Called when a circular reference is found.\n * It sets the {@link $Refs#circular} flag, executes the options.dereference.onCircular callback,\n * and throws an error if options.dereference.circular is false.\n *\n * @param keyPath - The JSON Reference path of the circular reference\n * @param $refs\n * @param options\n * @returns - always returns true, to indicate that a circular reference was found\n */\nfunction foundCircularReference(keyPath: any, $refs: any, options: any) {\n  $refs.circular \u003d true;\n  options?.dereference?.onCircular?.(keyPath);\n\n  if (!options.dereference.circular) {\n    throw ono.reference(`Circular $ref pointer found at ${keyPath}`);\n  }\n  return true;\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/index.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport $Refs from \"./refs.js\";\nimport _parse from \"./parse.js\";\nimport normalizeArgs from \"./normalize-args.js\";\nimport resolveExternal from \"./resolve-external.js\";\nimport _bundle from \"./bundle.js\";\nimport _dereference from \"./dereference.js\";\nimport * as url from \"./util/url.js\";\nimport {\n  JSONParserError,\n  InvalidPointerError,\n  MissingPointerError,\n  ResolverError,\n  ParserError,\n  UnmatchedParserError,\n  UnmatchedResolverError,\n  isHandledError,\n  JSONParserErrorGroup,\n} from \"./util/errors.js\";\nimport { ono } from \"@jsdevtools/ono\";\nimport maybe from \"./util/maybe.js\";\nimport type { ParserOptions } from \"./options.js\";\nimport { getJsonSchemaRefParserDefaultOptions } from \"./options.js\";\nimport type {\n  $RefsCallback,\n  JSONSchema,\n  SchemaCallback,\n  FileInfo,\n  Plugin,\n  ResolverOptions,\n  HTTPResolverOptions,\n} from \"./types/index.js\";\n\nexport type RefParserSchema \u003d string | JSONSchema;\n\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @class\n */\nexport class $RefParser\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e {\n  /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */\n  public schema: S | null \u003d null;\n\n  /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */\n  $refs \u003d new $Refs\u003cS, O\u003e();\n\n  /**\n   * Parses the given JSON schema.\n   * This method does not resolve any JSON references.\n   * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n   *\n   * @param [path] - The file path or URL of the JSON schema\n   * @param [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n   * @param [options] - Options that determine how the schema is parsed\n   * @param [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n   * @returns - The returned promise resolves with the parsed JSON schema object.\n   */\n  public parse(schema: S | string | unknown): Promise\u003cS\u003e;\n  public parse(schema: S | string | unknown, callback: SchemaCallback\u003cS\u003e): Promise\u003cvoid\u003e;\n  public parse(schema: S | string | unknown, options: O): Promise\u003cS\u003e;\n  public parse(schema: S | string | unknown, options: O, callback: SchemaCallback\u003cS\u003e): Promise\u003cvoid\u003e;\n  public parse(path: string, schema: S | string | unknown, options: O): Promise\u003cS\u003e;\n  public parse(path: string, schema: S | string | unknown, options: O, callback: SchemaCallback\u003cS\u003e): Promise\u003cvoid\u003e;\n  async parse() {\n    const args \u003d normalizeArgs\u003cS, O\u003e(arguments as any);\n    let promise;\n\n    if (!args.path \u0026\u0026 !args.schema) {\n      const err \u003d ono(`Expected a file path, URL, or object. Got ${args.path || args.schema}`);\n      return maybe(args.callback, Promise.reject(err));\n    }\n\n    // Reset everything\n    this.schema \u003d null;\n    this.$refs \u003d new $Refs();\n\n    // If the path is a filesystem path, then convert it to a URL.\n    // NOTE: According to the JSON Reference spec, these should already be URLs,\n    // but, in practice, many people use local filesystem paths instead.\n    // So we\u0027re being generous here and doing the conversion automatically.\n    // This is not intended to be a 100% bulletproof solution.\n    // If it doesn\u0027t work for your use-case, then use a URL instead.\n    let pathType \u003d \"http\";\n    if (url.isFileSystemPath(args.path)) {\n      args.path \u003d url.fromFileSystemPath(args.path);\n      pathType \u003d \"file\";\n    } else if (!args.path \u0026\u0026 args.schema \u0026\u0026 \"$id\" in args.schema \u0026\u0026 args.schema.$id) {\n      // when schema id has defined an URL should use that hostname to request the references,\n      // instead of using the current page URL\n      const params \u003d url.parse(args.schema.$id as string);\n      const port \u003d params.protocol \u003d\u003d\u003d \"https:\" ? 443 : 80;\n\n      args.path \u003d `${params.protocol}//${params.hostname}:${port}`;\n    }\n\n    // Resolve the absolute path of the schema\n    args.path \u003d url.resolve(url.cwd(), args.path);\n\n    if (args.schema \u0026\u0026 typeof args.schema \u003d\u003d\u003d \"object\") {\n      // A schema object was passed-in.\n      // So immediately add a new $Ref with the schema object as its value\n      const $ref \u003d this.$refs._add(args.path);\n      $ref.value \u003d args.schema;\n      $ref.pathType \u003d pathType;\n      promise \u003d Promise.resolve(args.schema);\n    } else {\n      // Parse the schema file/url\n      promise \u003d _parse\u003cS, typeof args.options\u003e(args.path, this.$refs, args.options);\n    }\n\n    try {\n      const result \u003d await promise;\n\n      if (result !\u003d\u003d null \u0026\u0026 typeof result \u003d\u003d\u003d \"object\" \u0026\u0026 !Buffer.isBuffer(result)) {\n        this.schema \u003d result;\n        return maybe(args.callback, Promise.resolve(this.schema!));\n      } else if (args.options.continueOnError) {\n        this.schema \u003d null; // it\u0027s already set to null at line 79, but let\u0027s set it again for the sake of readability\n        return maybe(args.callback, Promise.resolve(this.schema!));\n      } else {\n        throw ono.syntax(`\"${this.$refs._root$Ref.path || result}\" is not a valid JSON Schema`);\n      }\n    } catch (err) {\n      if (!args.options.continueOnError || !isHandledError(err)) {\n        return maybe(args.callback, Promise.reject(err));\n      }\n\n      if (this.$refs._$refs[url.stripHash(args.path)]) {\n        this.$refs._$refs[url.stripHash(args.path)].addError(err);\n      }\n\n      return maybe(args.callback, Promise.resolve(null));\n    }\n  }\n\n  public static parse\u003cS extends object \u003d JSONSchema\u003e(schema: S | string | unknown): Promise\u003cS\u003e;\n  public static parse\u003cS extends object \u003d JSONSchema\u003e(\n    schema: S | string | unknown,\n    callback: SchemaCallback\u003cS\u003e,\n  ): Promise\u003cvoid\u003e;\n  public static parse\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    schema: S | string | unknown,\n    options: O,\n  ): Promise\u003cS\u003e;\n  public static parse\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    schema: S | string | unknown,\n    options: O,\n    callback: SchemaCallback\u003cS\u003e,\n  ): Promise\u003cvoid\u003e;\n  public static parse\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    path: string,\n    schema: S | string | unknown,\n    options: O,\n  ): Promise\u003cS\u003e;\n  public static parse\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    path: string,\n    schema: S | string | unknown,\n    options: O,\n    callback: SchemaCallback\u003cS\u003e,\n  ): Promise\u003cvoid\u003e;\n  public static parse\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e():\n    | Promise\u003cS\u003e\n    | Promise\u003cvoid\u003e {\n    const parser \u003d new $RefParser\u003cS, O\u003e();\n    return parser.parse.apply(parser, arguments as any);\n  }\n\n  /**\n   * *This method is used internally by other methods, such as `bundle` and `dereference`. You probably won\u0027t need to call this method yourself.*\n   *\n   * Resolves all JSON references (`$ref` pointers) in the given JSON Schema file. If it references any other files/URLs, then they will be downloaded and resolved as well. This method **does not** dereference anything. It simply gives you a `$Refs` object, which is a map of all the resolved references and their values.\n   *\n   * See https://apitools.dev/json-schema-ref-parser/docs/ref-parser.html#resolveschema-options-callback\n   *\n   * @param schema A JSON Schema object, or the file path or URL of a JSON Schema file. See the `parse` method for more info.\n   * @param options (optional)\n   * @param callback (optional) A callback that will receive a `$Refs` object\n   */\n  public resolve(schema: S | string | unknown): Promise\u003c$Refs\u003cS, O\u003e\u003e;\n  public resolve(schema: S | string | unknown, callback: $RefsCallback\u003cS, O\u003e): Promise\u003cvoid\u003e;\n  public resolve(schema: S | string | unknown, options: O): Promise\u003c$Refs\u003cS, O\u003e\u003e;\n  public resolve(schema: S | string | unknown, options: O, callback: $RefsCallback\u003cS, O\u003e): Promise\u003cvoid\u003e;\n  public resolve(path: string, schema: S | string | unknown, options: O): Promise\u003c$Refs\u003cS, O\u003e\u003e;\n  public resolve(\n    path: string,\n    schema: S | string | unknown,\n    options: O,\n    callback: $RefsCallback\u003cS, O\u003e,\n  ): Promise\u003cvoid\u003e;\n  async resolve() {\n    const args \u003d normalizeArgs\u003cS, O\u003e(arguments);\n\n    try {\n      await this.parse(args.path, args.schema, args.options);\n      await resolveExternal(this, args.options);\n      finalize(this);\n      return maybe(args.callback, Promise.resolve(this.$refs));\n    } catch (err) {\n      return maybe(args.callback, Promise.reject(err));\n    }\n  }\n\n  /**\n   * *This method is used internally by other methods, such as `bundle` and `dereference`. You probably won\u0027t need to call this method yourself.*\n   *\n   * Resolves all JSON references (`$ref` pointers) in the given JSON Schema file. If it references any other files/URLs, then they will be downloaded and resolved as well. This method **does not** dereference anything. It simply gives you a `$Refs` object, which is a map of all the resolved references and their values.\n   *\n   * See https://apitools.dev/json-schema-ref-parser/docs/ref-parser.html#resolveschema-options-callback\n   *\n   * @param schema A JSON Schema object, or the file path or URL of a JSON Schema file. See the `parse` method for more info.\n   * @param options (optional)\n   * @param callback (optional) A callback that will receive a `$Refs` object\n   */\n  public static resolve\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    schema: S | string | unknown,\n  ): Promise\u003c$Refs\u003cS, O\u003e\u003e;\n  public static resolve\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    schema: S | string | unknown,\n    callback: $RefsCallback\u003cS, O\u003e,\n  ): Promise\u003cvoid\u003e;\n  public static resolve\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    schema: S | string | unknown,\n    options: O,\n  ): Promise\u003c$Refs\u003cS, O\u003e\u003e;\n  public static resolve\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    schema: S | string | unknown,\n    options: O,\n    callback: $RefsCallback\u003cS, O\u003e,\n  ): Promise\u003cvoid\u003e;\n  public static resolve\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    path: string,\n    schema: S | string | unknown,\n    options: O,\n  ): Promise\u003c$Refs\u003cS, O\u003e\u003e;\n  public static resolve\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    path: string,\n    schema: S | string | unknown,\n    options: O,\n    callback: $RefsCallback\u003cS, O\u003e,\n  ): Promise\u003cvoid\u003e;\n  static resolve\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e():\n    | Promise\u003cS\u003e\n    | Promise\u003cvoid\u003e {\n    const instance \u003d new $RefParser\u003cS, O\u003e();\n    return instance.resolve.apply(instance, arguments as any);\n  }\n\n  /**\n   * Bundles all referenced files/URLs into a single schema that only has internal `$ref` pointers. This lets you split-up your schema however you want while you\u0027re building it, but easily combine all those files together when it\u0027s time to package or distribute the schema to other people. The resulting schema size will be small, since it will still contain internal JSON references rather than being fully-dereferenced.\n   *\n   * This also eliminates the risk of circular references, so the schema can be safely serialized using `JSON.stringify()`.\n   *\n   * See https://apitools.dev/json-schema-ref-parser/docs/ref-parser.html#bundleschema-options-callback\n   *\n   * @param schema A JSON Schema object, or the file path or URL of a JSON Schema file. See the `parse` method for more info.\n   * @param options (optional)\n   * @param callback (optional) A callback that will receive the bundled schema object\n   */\n  public static bundle\u003cS extends object \u003d JSONSchema\u003e(schema: S | string | unknown): Promise\u003cS\u003e;\n  public static bundle\u003cS extends object \u003d JSONSchema\u003e(\n    schema: S | string | unknown,\n    callback: SchemaCallback\u003cS\u003e,\n  ): Promise\u003cvoid\u003e;\n  public static bundle\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    schema: S | string | unknown,\n    options: O,\n  ): Promise\u003cS\u003e;\n  public static bundle\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    schema: S | string | unknown,\n    options: O,\n    callback: SchemaCallback\u003cS\u003e,\n  ): Promise\u003cvoid\u003e;\n  public static bundle\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    path: string,\n    schema: S | string | unknown,\n    options: O,\n  ): Promise\u003cS\u003e;\n  public static bundle\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    path: string,\n    schema: S | string | unknown,\n    options: O,\n    callback: SchemaCallback\u003cS\u003e,\n  ): Promise\u003cS\u003e;\n  static bundle\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e():\n    | Promise\u003cS\u003e\n    | Promise\u003cvoid\u003e {\n    const instance \u003d new $RefParser\u003cS, O\u003e();\n    return instance.bundle.apply(instance, arguments as any);\n  }\n\n  /**\n   * Bundles all referenced files/URLs into a single schema that only has internal `$ref` pointers. This lets you split-up your schema however you want while you\u0027re building it, but easily combine all those files together when it\u0027s time to package or distribute the schema to other people. The resulting schema size will be small, since it will still contain internal JSON references rather than being fully-dereferenced.\n   *\n   * This also eliminates the risk of circular references, so the schema can be safely serialized using `JSON.stringify()`.\n   *\n   * See https://apitools.dev/json-schema-ref-parser/docs/ref-parser.html#bundleschema-options-callback\n   *\n   * @param schema A JSON Schema object, or the file path or URL of a JSON Schema file. See the `parse` method for more info.\n   * @param options (optional)\n   * @param callback (optional) A callback that will receive the bundled schema object\n   */\n  public bundle(schema: S | string | unknown): Promise\u003cS\u003e;\n  public bundle(schema: S | string | unknown, callback: SchemaCallback\u003cS\u003e): Promise\u003cvoid\u003e;\n  public bundle(schema: S | string | unknown, options: O): Promise\u003cS\u003e;\n  public bundle(schema: S | string | unknown, options: O, callback: SchemaCallback\u003cS\u003e): Promise\u003cvoid\u003e;\n  public bundle(path: string, schema: S | string | unknown, options: O): Promise\u003cS\u003e;\n  public bundle(path: string, schema: S | string | unknown, options: O, callback: SchemaCallback\u003cS\u003e): Promise\u003cvoid\u003e;\n  async bundle() {\n    const args \u003d normalizeArgs\u003cS, O\u003e(arguments);\n    try {\n      await this.resolve(args.path, args.schema, args.options);\n      _bundle\u003cS, O\u003e(this, args.options);\n      finalize(this);\n      return maybe(args.callback, Promise.resolve(this.schema!));\n    } catch (err) {\n      return maybe(args.callback, Promise.reject(err));\n    }\n  }\n\n  /**\n   * Dereferences all `$ref` pointers in the JSON Schema, replacing each reference with its resolved value. This results in a schema object that does not contain any `$ref` pointers. Instead, it\u0027s a normal JavaScript object tree that can easily be crawled and used just like any other JavaScript object. This is great for programmatic usage, especially when using tools that don\u0027t understand JSON references.\n   *\n   * The dereference method maintains object reference equality, meaning that all `$ref` pointers that point to the same object will be replaced with references to the same object. Again, this is great for programmatic usage, but it does introduce the risk of circular references, so be careful if you intend to serialize the schema using `JSON.stringify()`. Consider using the bundle method instead, which does not create circular references.\n   *\n   * See https://apitools.dev/json-schema-ref-parser/docs/ref-parser.html#dereferenceschema-options-callback\n   *\n   * @param schema A JSON Schema object, or the file path or URL of a JSON Schema file. See the `parse` method for more info.\n   * @param options (optional)\n   * @param callback (optional) A callback that will receive the dereferenced schema object\n   */\n  public static dereference\u003cS extends object \u003d JSONSchema\u003e(schema: S | string | unknown): Promise\u003cS\u003e;\n  public static dereference\u003cS extends object \u003d JSONSchema\u003e(\n    schema: S | string | unknown,\n    callback: SchemaCallback\u003cS\u003e,\n  ): Promise\u003cvoid\u003e;\n  public static dereference\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    schema: S | string | unknown,\n    options: O,\n  ): Promise\u003cS\u003e;\n  public static dereference\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    schema: S | string | unknown,\n    options: O,\n    callback: SchemaCallback\u003cS\u003e,\n  ): Promise\u003cvoid\u003e;\n  public static dereference\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    path: string,\n    schema: S | string | unknown,\n    options: O,\n  ): Promise\u003cS\u003e;\n  public static dereference\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    path: string,\n    schema: S | string | unknown,\n    options: O,\n    callback: SchemaCallback\u003cS\u003e,\n  ): Promise\u003cvoid\u003e;\n  static dereference\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e():\n    | Promise\u003cS\u003e\n    | Promise\u003cvoid\u003e {\n    const instance \u003d new $RefParser\u003cS, O\u003e();\n    return instance.dereference.apply(instance, arguments as any);\n  }\n\n  /**\n   * Dereferences all `$ref` pointers in the JSON Schema, replacing each reference with its resolved value. This results in a schema object that does not contain any `$ref` pointers. Instead, it\u0027s a normal JavaScript object tree that can easily be crawled and used just like any other JavaScript object. This is great for programmatic usage, especially when using tools that don\u0027t understand JSON references.\n   *\n   * The dereference method maintains object reference equality, meaning that all `$ref` pointers that point to the same object will be replaced with references to the same object. Again, this is great for programmatic usage, but it does introduce the risk of circular references, so be careful if you intend to serialize the schema using `JSON.stringify()`. Consider using the bundle method instead, which does not create circular references.\n   *\n   * See https://apitools.dev/json-schema-ref-parser/docs/ref-parser.html#dereferenceschema-options-callback\n   *\n   * @param path\n   * @param schema A JSON Schema object, or the file path or URL of a JSON Schema file. See the `parse` method for more info.\n   * @param options (optional)\n   * @param callback (optional) A callback that will receive the dereferenced schema object\n   */\n  public dereference(\n    path: string,\n    schema: S | string | unknown,\n    options: O,\n    callback: SchemaCallback\u003cS\u003e,\n  ): Promise\u003cvoid\u003e;\n  public dereference(schema: S | string | unknown, options: O, callback: SchemaCallback\u003cS\u003e): Promise\u003cvoid\u003e;\n  public dereference(schema: S | string | unknown, callback: SchemaCallback\u003cS\u003e): Promise\u003cvoid\u003e;\n  public dereference(path: string, schema: S | string | unknown, options: O): Promise\u003cS\u003e;\n  public dereference(schema: S | string | unknown, options: O): Promise\u003cS\u003e;\n  public dereference(schema: S | string | unknown): Promise\u003cS\u003e;\n  async dereference() {\n    const args \u003d normalizeArgs\u003cS, O\u003e(arguments);\n\n    try {\n      await this.resolve(args.path, args.schema, args.options);\n      _dereference(this, args.options);\n      finalize(this);\n      return maybe\u003cS\u003e(args.callback, Promise.resolve(this.schema!) as Promise\u003cS\u003e);\n    } catch (err) {\n      return maybe\u003cS\u003e(args.callback, Promise.reject(err));\n    }\n  }\n}\nexport default $RefParser;\n\nfunction finalize\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  parser: $RefParser\u003cS, O\u003e,\n) {\n  const errors \u003d JSONParserErrorGroup.getParserErrors(parser);\n  if (errors.length \u003e 0) {\n    throw new JSONParserErrorGroup(parser);\n  }\n}\n\nexport const parse \u003d $RefParser.parse;\nexport const resolve \u003d $RefParser.resolve;\nexport const bundle \u003d $RefParser.bundle;\nexport const dereference \u003d $RefParser.dereference;\n\nexport {\n  UnmatchedResolverError,\n  JSONParserError,\n  JSONSchema,\n  InvalidPointerError,\n  MissingPointerError,\n  ResolverError,\n  ParserError,\n  UnmatchedParserError,\n  ParserOptions,\n  $RefsCallback,\n  isHandledError,\n  JSONParserErrorGroup,\n  SchemaCallback,\n  FileInfo,\n  Plugin,\n  ResolverOptions,\n  HTTPResolverOptions,\n  _dereference as dereferenceInternal,\n  normalizeArgs as jsonSchemaParserNormalizeArgs,\n  getJsonSchemaRefParserDefaultOptions,\n};\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/normalize-args.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport type { Options, ParserOptions } from \"./options.js\";\nimport { getNewOptions } from \"./options.js\";\nimport type { JSONSchema, SchemaCallback } from \"./types\";\n\n// I really dislike this function and the way it\u0027s written. It\u0027s not clear what it\u0027s doing, and it\u0027s way too flexible\n// In the future, I\u0027d like to deprecate the api and accept only named parameters in index.ts\nexport interface NormalizedArguments\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e {\n  path: string;\n  schema: S;\n  options: O \u0026 Options\u003cS\u003e;\n  callback: SchemaCallback\u003cS\u003e;\n}\n/**\n * Normalizes the given arguments, accounting for optional args.\n */\nexport function normalizeArgs\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  _args: Partial\u003cIArguments\u003e,\n): NormalizedArguments\u003cS, O\u003e {\n  let path;\n  let schema;\n  let options: Options\u003cS\u003e \u0026 O;\n  let callback;\n  const args \u003d Array.prototype.slice.call(_args) as any[];\n\n  if (typeof args[args.length - 1] \u003d\u003d\u003d \"function\") {\n    // The last parameter is a callback function\n    callback \u003d args.pop();\n  }\n\n  if (typeof args[0] \u003d\u003d\u003d \"string\") {\n    // The first parameter is the path\n    path \u003d args[0];\n    if (typeof args[2] \u003d\u003d\u003d \"object\") {\n      // The second parameter is the schema, and the third parameter is the options\n      schema \u003d args[1];\n      options \u003d args[2];\n    } else {\n      // The second parameter is the options\n      schema \u003d undefined;\n      options \u003d args[1];\n    }\n  } else {\n    // The first parameter is the schema\n    path \u003d \"\";\n    schema \u003d args[0];\n    options \u003d args[1];\n  }\n\n  try {\n    options \u003d getNewOptions\u003cS, O\u003e(options);\n  } catch (e) {\n    console.error(`JSON Schema Ref Parser: Error normalizing options: ${e}`);\n  }\n\n  if (!options.mutateInputSchema \u0026\u0026 typeof schema \u003d\u003d\u003d \"object\") {\n    // Make a deep clone of the schema, so that we don\u0027t alter the original object\n    schema \u003d JSON.parse(JSON.stringify(schema));\n  }\n\n  return {\n    path,\n    schema,\n    options,\n    callback,\n  };\n}\n\nexport default normalizeArgs;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/options.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport jsonParser from \"./parsers/json.js\";\nimport yamlParser from \"./parsers/yaml.js\";\nimport textParser from \"./parsers/text.js\";\nimport binaryParser from \"./parsers/binary.js\";\nimport fileResolver from \"./resolvers/file.js\";\nimport httpResolver from \"./resolvers/http.js\";\n\nimport type { HTTPResolverOptions, JSONSchema, JSONSchemaObject, Plugin, ResolverOptions } from \"./types/index.js\";\n\nexport type DeepPartial\u003cT\u003e \u003d T extends object\n  ? {\n      [P in keyof T]?: DeepPartial\u003cT[P]\u003e;\n    }\n  : T;\nexport interface DereferenceOptions {\n  /**\n   * Determines whether circular `$ref` pointers are handled.\n   *\n   * If set to `false`, then a `ReferenceError` will be thrown if the schema contains any circular references.\n   *\n   * If set to `\"ignore\"`, then circular references will simply be ignored. No error will be thrown, but the `$Refs.circular` property will still be set to `true`.\n   */\n  circular?: boolean | \"ignore\";\n\n  /**\n   * A function, called for each path, which can return true to stop this path and all\n   * subpaths from being dereferenced further. This is useful in schemas where some\n   * subpaths contain literal $ref keys that should not be dereferenced.\n   */\n  excludedPathMatcher?(path: string): boolean;\n\n  /**\n   * Callback invoked during circular reference detection.\n   *\n   * @argument {string} path - The path that is circular (ie. the `$ref` string)\n   */\n  onCircular?(path: string): void;\n\n  /**\n   * Callback invoked during dereferencing.\n   *\n   * @argument {string} path - The path being dereferenced (ie. the `$ref` string)\n   * @argument {JSONSchemaObject} value - The JSON-Schema that the `$ref` resolved to\n   * @argument {JSONSchemaObject} parent - The parent of the dereferenced object\n   * @argument {string} parentPropName - The prop name of the parent object whose value was dereferenced\n   */\n  onDereference?(path: string, value: JSONSchemaObject, parent?: JSONSchemaObject, parentPropName?: string): void;\n\n  /**\n   * An array of properties to preserve when dereferencing a `$ref` schema. Useful if you want to\n   * enforce non-standard dereferencing behavior like present in the OpenAPI 3.1 specification where\n   * `description` and `summary` properties are preserved when alongside a `$ref` pointer.\n   *\n   * If none supplied then no properties will be preserved and the object will be fully replaced\n   * with the dereferenced `$ref`.\n   */\n  preservedProperties?: string[];\n\n  /**\n   * Whether a reference should resolve relative to its directory/path, or from the cwd\n   *\n   * Default: `relative`\n   */\n  externalReferenceResolution?: \"relative\" | \"root\";\n}\n\n/**\n * Options that determine how JSON schemas are parsed, resolved, and dereferenced.\n *\n * @param [options] - Overridden options\n * @class\n */\nexport interface $RefParserOptions\u003cS extends object \u003d JSONSchema\u003e {\n  /**\n   * The `parse` options determine how different types of files will be parsed.\n   *\n   * JSON Schema `$Ref` Parser comes with built-in JSON, YAML, plain-text, and binary parsers, any of which you can configure or disable. You can also add your own custom parsers if you want.\n   */\n  parse: {\n    json?: Plugin | boolean;\n    yaml?: Plugin | boolean;\n    binary?: Plugin | boolean;\n    text?: Plugin | boolean;\n    [key: string]: Plugin | boolean | undefined;\n  };\n\n  /**\n   * The `resolve` options control how JSON Schema $Ref Parser will resolve file paths and URLs, and how those files will be read/downloaded.\n   *\n   * JSON Schema `$Ref` Parser comes with built-in support for HTTP and HTTPS, as well as support for local files (when running in Node.js). You can configure or disable either of these built-in resolvers. You can also add your own custom resolvers if you want.\n   */\n  resolve: {\n    /**\n     * Determines whether external $ref pointers will be resolved. If this option is disabled, then external `$ref` pointers will simply be ignored.\n     */\n    external?: boolean;\n    file?: Partial\u003cResolverOptions\u003cS\u003e\u003e | boolean;\n    http?: HTTPResolverOptions\u003cS\u003e | boolean;\n  } \u0026 {\n    [key: string]: Partial\u003cResolverOptions\u003cS\u003e\u003e | HTTPResolverOptions\u003cS\u003e | boolean | undefined;\n  };\n\n  /**\n   * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`\n   * causes it to keep processing as much as possible and then throw a single error that contains all errors\n   * that were encountered.\n   */\n  continueOnError: boolean;\n\n  /**\n   * The `dereference` options control how JSON Schema `$Ref` Parser will dereference `$ref` pointers within the JSON schema.\n   */\n  dereference: DereferenceOptions;\n\n  /**\n   * Whether to clone the schema before dereferencing it.\n   * This is useful when you want to dereference the same schema multiple times, but you don\u0027t want to modify the original schema.\n   * Default: `true` due to mutating the input being the default behavior historically\n   */\n  mutateInputSchema?: boolean;\n\n  /**\n   * The maximum amount of time (in milliseconds) that JSON Schema $Ref Parser will spend dereferencing a single schema.\n   * It will throw a timeout error if the operation takes longer than this.\n   */\n  timeoutMs?: number;\n}\n\nexport const getJsonSchemaRefParserDefaultOptions \u003d () \u003d\u003e {\n  const defaults \u003d {\n    /**\n     * Determines how different types of files will be parsed.\n     *\n     * You can add additional parsers of your own, replace an existing one with\n     * your own implementation, or disable any parser by setting it to false.\n     */\n    parse: {\n      json: { ...jsonParser },\n      yaml: { ...yamlParser },\n      text: { ...textParser },\n      binary: { ...binaryParser },\n    },\n\n    /**\n     * Determines how JSON References will be resolved.\n     *\n     * You can add additional resolvers of your own, replace an existing one with\n     * your own implementation, or disable any resolver by setting it to false.\n     */\n    resolve: {\n      file: { ...fileResolver },\n      http: { ...httpResolver },\n\n      /**\n       * Determines whether external $ref pointers will be resolved.\n       * If this option is disabled, then none of above resolvers will be called.\n       * Instead, external $ref pointers will simply be ignored.\n       *\n       * @type {boolean}\n       */\n      external: true,\n    },\n\n    /**\n     * By default, JSON Schema $Ref Parser throws the first error it encounters. Setting `continueOnError` to `true`\n     * causes it to keep processing as much as possible and then throw a single error that contains all errors\n     * that were encountered.\n     */\n    continueOnError: false,\n\n    /**\n     * Determines the types of JSON references that are allowed.\n     */\n    dereference: {\n      /**\n       * Dereference circular (recursive) JSON references?\n       * If false, then a {@link ReferenceError} will be thrown if a circular reference is found.\n       * If \"ignore\", then circular references will not be dereferenced.\n       *\n       * @type {boolean|string}\n       */\n      circular: true,\n\n      /**\n       * A function, called for each path, which can return true to stop this path and all\n       * subpaths from being dereferenced further. This is useful in schemas where some\n       * subpaths contain literal $ref keys that should not be dereferenced.\n       *\n       * @type {function}\n       */\n      excludedPathMatcher: () \u003d\u003e false,\n      referenceResolution: \"relative\",\n    },\n\n    mutateInputSchema: true,\n  } as $RefParserOptions\u003cJSONSchema\u003e;\n  return defaults;\n};\n\nexport const getNewOptions \u003d \u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  options: O | undefined,\n): O \u0026 $RefParserOptions\u003cS\u003e \u003d\u003e {\n  const newOptions \u003d getJsonSchemaRefParserDefaultOptions();\n  if (options) {\n    merge(newOptions, options);\n  }\n  return newOptions as O \u0026 $RefParserOptions\u003cS\u003e;\n};\n\nexport type Options\u003cS extends object \u003d JSONSchema\u003e \u003d $RefParserOptions\u003cS\u003e;\nexport type ParserOptions\u003cS extends object \u003d JSONSchema\u003e \u003d DeepPartial\u003c$RefParserOptions\u003cS\u003e\u003e;\n/**\n * Merges the properties of the source object into the target object.\n *\n * @param target - The object that we\u0027re populating\n * @param source - The options that are being merged\n * @returns\n */\nfunction merge(target: any, source: any) {\n  if (isMergeable(source)) {\n    // prevent prototype pollution\n    const keys \u003d Object.keys(source).filter((key) \u003d\u003e ![\"__proto__\", \"constructor\", \"prototype\"].includes(key));\n    for (let i \u003d 0; i \u003c keys.length; i++) {\n      const key \u003d keys[i];\n      const sourceSetting \u003d source[key];\n      const targetSetting \u003d target[key];\n\n      if (isMergeable(sourceSetting)) {\n        // It\u0027s a nested object, so merge it recursively\n        target[key] \u003d merge(targetSetting || {}, sourceSetting);\n      } else if (sourceSetting !\u003d\u003d undefined) {\n        // It\u0027s a scalar value, function, or array. No merging necessary. Just overwrite the target value.\n        target[key] \u003d sourceSetting;\n      }\n    }\n  }\n  return target;\n}\n/**\n * Determines whether the given value can be merged,\n * or if it is a scalar value that should just override the target value.\n *\n * @param val\n * @returns\n */\nfunction isMergeable(val: any) {\n  return val \u0026\u0026 typeof val \u003d\u003d\u003d \"object\" \u0026\u0026 !Array.isArray(val) \u0026\u0026 !(val instanceof RegExp) \u0026\u0026 !(val instanceof Date);\n}\nexport default $RefParserOptions;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/parse.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport { ono } from \"@jsdevtools/ono\";\nimport * as url from \"./util/url.js\";\nimport * as plugins from \"./util/plugins.js\";\nimport {\n  ResolverError,\n  ParserError,\n  UnmatchedParserError,\n  UnmatchedResolverError,\n  isHandledError,\n} from \"./util/errors.js\";\nimport type $Refs from \"./refs.js\";\nimport type { ParserOptions } from \"./options.js\";\nimport type { FileInfo, JSONSchema } from \"./types/index.js\";\n\n/**\n * Reads and parses the specified file path or URL.\n */\nasync function parse\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  path: string,\n  $refs: $Refs\u003cS, O\u003e,\n  options: O,\n) {\n  // Remove the URL fragment, if any\n  const hashIndex \u003d path.indexOf(\"#\");\n  let hash \u003d \"\";\n  if (hashIndex \u003e\u003d 0) {\n    hash \u003d path.substring(hashIndex);\n    // Remove the URL fragment, if any\n    path \u003d path.substring(0, hashIndex);\n  }\n\n  // Add a new $Ref for this file, even though we don\u0027t have the value yet.\n  // This ensures that we don\u0027t simultaneously read \u0026 parse the same file multiple times\n  const $ref \u003d $refs._add(path);\n\n  // This \"file object\" will be passed to all resolvers and parsers.\n  const file \u003d {\n    url: path,\n    hash,\n    extension: url.getExtension(path),\n  } as FileInfo;\n\n  // Read the file and then parse the data\n  try {\n    const resolver \u003d await readFile\u003cS, O\u003e(file, options, $refs);\n    $ref.pathType \u003d resolver.plugin.name;\n    file.data \u003d resolver.result;\n\n    const parser \u003d await parseFile\u003cS, O\u003e(file, options, $refs);\n    $ref.value \u003d parser.result;\n\n    return parser.result;\n  } catch (err) {\n    if (isHandledError(err)) {\n      $ref.value \u003d err;\n    }\n\n    throw err;\n  }\n}\n\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param file           - An object containing information about the referenced file\n * @param file.url       - The full URL of the referenced file\n * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param options\n * @param $refs\n * @returns\n * The promise resolves with the raw file contents and the resolver that was used.\n */\nasync function readFile\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  file: FileInfo,\n  options: O,\n  $refs: $Refs\u003cS, O\u003e,\n): Promise\u003cany\u003e {\n  // console.log(\u0027Reading %s\u0027, file.url);\n\n  // Find the resolvers that can read this file\n  let resolvers \u003d plugins.all(options.resolve);\n  resolvers \u003d plugins.filter(resolvers, \"canRead\", file);\n\n  // Run the resolvers, in order, until one of them succeeds\n  plugins.sort(resolvers);\n  try {\n    const data \u003d await plugins.run(resolvers, \"read\", file, $refs);\n    return data;\n  } catch (err: any) {\n    if (!err \u0026\u0026 options.continueOnError) {\n      // No resolver could be matched\n      throw new UnmatchedResolverError(file.url);\n    } else if (!err || !(\"error\" in err)) {\n      // Throw a generic, friendly error.\n      throw ono.syntax(`Unable to resolve $ref pointer \"${file.url}\"`);\n    }\n    // Throw the original error, if it\u0027s one of our own (user-friendly) errors.\n    else if (err.error instanceof ResolverError) {\n      throw err.error;\n    } else {\n      throw new ResolverError(err, file.url);\n    }\n  }\n}\n\n/**\n * Parses the given file\u0027s contents, using the configured parser plugins.\n *\n * @param file           - An object containing information about the referenced file\n * @param file.url       - The full URL of the referenced file\n * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param options\n * @param $refs\n *\n * @returns\n * The promise resolves with the parsed file contents and the parser that was used.\n */\nasync function parseFile\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  file: FileInfo,\n  options: O,\n  $refs: $Refs\u003cS, O\u003e,\n) {\n  // Find the parsers that can read this file type.\n  // If none of the parsers are an exact match for this file, then we\u0027ll try ALL of them.\n  // This handles situations where the file IS a supported type, just with an unknown extension.\n  const allParsers \u003d plugins.all(options.parse);\n  const filteredParsers \u003d plugins.filter(allParsers, \"canParse\", file);\n  const parsers \u003d filteredParsers.length \u003e 0 ? filteredParsers : allParsers;\n\n  // Run the parsers, in order, until one of them succeeds\n  plugins.sort(parsers);\n  try {\n    const parser \u003d await plugins.run\u003cS, O\u003e(parsers, \"parse\", file, $refs);\n    if (!parser.plugin.allowEmpty \u0026\u0026 isEmpty(parser.result)) {\n      throw ono.syntax(`Error parsing \"${file.url}\" as ${parser.plugin.name}. \\nParsed value is empty`);\n    } else {\n      return parser;\n    }\n  } catch (err: any) {\n    if (!err \u0026\u0026 options.continueOnError) {\n      // No resolver could be matched\n      throw new UnmatchedParserError(file.url);\n    } else if (err \u0026\u0026 err.message \u0026\u0026 err.message.startsWith(\"Error parsing\")) {\n      throw err;\n    } else if (!err || !(\"error\" in err)) {\n      throw ono.syntax(`Unable to parse ${file.url}`);\n    } else if (err.error instanceof ParserError) {\n      throw err.error;\n    } else {\n      throw new ParserError(err.error.message, file.url);\n    }\n  }\n}\n\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param value\n * @returns\n */\nfunction isEmpty(value: any) {\n  return (\n    value \u003d\u003d\u003d undefined ||\n    (typeof value \u003d\u003d\u003d \"object\" \u0026\u0026 Object.keys(value).length \u003d\u003d\u003d 0) ||\n    (typeof value \u003d\u003d\u003d \"string\" \u0026\u0026 value.trim().length \u003d\u003d\u003d 0) ||\n    (Buffer.isBuffer(value) \u0026\u0026 value.length \u003d\u003d\u003d 0)\n  );\n}\nexport default parse;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/pointer.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport type { ParserOptions } from \"./options.js\";\n\nimport $Ref from \"./ref.js\";\nimport * as url from \"./util/url.js\";\nimport { JSONParserError, InvalidPointerError, MissingPointerError, isHandledError } from \"./util/errors.js\";\nimport type { JSONSchema } from \"./types\";\n\nconst slashes \u003d /\\//g;\nconst tildes \u003d /~/g;\nconst escapedSlash \u003d /~1/g;\nconst escapedTilde \u003d /~0/g;\n\nconst safeDecodeURIComponent \u003d (encodedURIComponent: string): string \u003d\u003e {\n  try {\n    return decodeURIComponent(encodedURIComponent);\n  } catch {\n    return encodedURIComponent;\n  }\n};\n\n/**\n * This class represents a single JSON pointer and its resolved value.\n *\n * @param $ref\n * @param path\n * @param [friendlyPath] - The original user-specified path (used for error messages)\n * @class\n */\nclass Pointer\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e {\n  /**\n   * The {@link $Ref} object that contains this {@link Pointer} object.\n   */\n  $ref: $Ref\u003cS, O\u003e;\n\n  /**\n   * The file path or URL, containing the JSON pointer in the hash.\n   * This path is relative to the path of the main JSON schema file.\n   */\n  path: string;\n\n  /**\n   * The original path or URL, used for error messages.\n   */\n  originalPath: string;\n\n  /**\n   * The value of the JSON pointer.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   */\n\n  value: any;\n  /**\n   * Indicates whether the pointer references itself.\n   */\n  circular: boolean;\n  /**\n   * The number of indirect references that were traversed to resolve the value.\n   * Resolving a single pointer may require resolving multiple $Refs.\n   */\n  indirections: number;\n\n  constructor($ref: $Ref\u003cS, O\u003e, path: string, friendlyPath?: string) {\n    this.$ref \u003d $ref;\n\n    this.path \u003d path;\n\n    this.originalPath \u003d friendlyPath || path;\n\n    this.value \u003d undefined;\n\n    this.circular \u003d false;\n\n    this.indirections \u003d 0;\n  }\n\n  /**\n   * Resolves the value of a nested property within the given object.\n   *\n   * @param obj - The object that will be crawled\n   * @param options\n   * @param pathFromRoot - the path of place that initiated resolving\n   *\n   * @returns\n   * Returns a JSON pointer whose {@link Pointer#value} is the resolved value.\n   * If resolving this value required resolving other JSON references, then\n   * the {@link Pointer#$ref} and {@link Pointer#path} will reflect the resolution path\n   * of the resolved value.\n   */\n  resolve(obj: S, options?: O, pathFromRoot?: string) {\n    const tokens \u003d Pointer.parse(this.path, this.originalPath);\n    const found: any \u003d [];\n\n    // Crawl the object, one token at a time\n    this.value \u003d unwrapOrThrow(obj);\n\n    for (let i \u003d 0; i \u003c tokens.length; i++) {\n      if (resolveIf$Ref(this, options, pathFromRoot)) {\n        // The $ref path has changed, so append the remaining tokens to the path\n        this.path \u003d Pointer.join(this.path, tokens.slice(i));\n      }\n\n      if (typeof this.value \u003d\u003d\u003d \"object\" \u0026\u0026 this.value !\u003d\u003d null \u0026\u0026 !isRootPath(pathFromRoot) \u0026\u0026 \"$ref\" in this.value) {\n        return this;\n      }\n\n      const token \u003d tokens[i];\n\n      if (this.value[token] \u003d\u003d\u003d undefined || (this.value[token] \u003d\u003d\u003d null \u0026\u0026 i \u003d\u003d\u003d tokens.length - 1)) {\n        // one final case is if the entry itself includes slashes, and was parsed out as a token - we can join the remaining tokens and try again\n        let didFindSubstringSlashMatch \u003d false;\n        for (let j \u003d tokens.length - 1; j \u003e i; j--) {\n          const joinedToken \u003d tokens.slice(i, j + 1).join(\"/\");\n          if (this.value[joinedToken] !\u003d\u003d undefined) {\n            this.value \u003d this.value[joinedToken];\n            i \u003d j;\n            didFindSubstringSlashMatch \u003d true;\n            break;\n          }\n        }\n        if (didFindSubstringSlashMatch) {\n          continue;\n        }\n\n        this.value \u003d null;\n\n        const path \u003d this.$ref.path || \"\";\n\n        const targetRef \u003d this.path.replace(path, \"\");\n        const targetFound \u003d Pointer.join(\"\", found);\n        const parentPath \u003d pathFromRoot?.replace(path, \"\");\n\n        throw new MissingPointerError(token, decodeURI(this.originalPath), targetRef, targetFound, parentPath);\n      } else {\n        this.value \u003d this.value[token];\n      }\n\n      found.push(token);\n    }\n\n    // Resolve the final value\n    if (!this.value || (this.value.$ref \u0026\u0026 url.resolve(this.path, this.value.$ref) !\u003d\u003d pathFromRoot)) {\n      resolveIf$Ref(this, options, pathFromRoot);\n    }\n\n    return this;\n  }\n\n  /**\n   * Sets the value of a nested property within the given object.\n   *\n   * @param obj - The object that will be crawled\n   * @param value - the value to assign\n   * @param options\n   *\n   * @returns\n   * Returns the modified object, or an entirely new object if the entire object is overwritten.\n   */\n  set(obj: S, value: any, options?: O) {\n    const tokens \u003d Pointer.parse(this.path);\n    let token;\n\n    if (tokens.length \u003d\u003d\u003d 0) {\n      // There are no tokens, replace the entire object with the new value\n      this.value \u003d value;\n      return value;\n    }\n\n    // Crawl the object, one token at a time\n    this.value \u003d unwrapOrThrow(obj);\n\n    for (let i \u003d 0; i \u003c tokens.length - 1; i++) {\n      resolveIf$Ref(this, options);\n\n      token \u003d tokens[i];\n      if (this.value \u0026\u0026 this.value[token] !\u003d\u003d undefined) {\n        // The token exists\n        this.value \u003d this.value[token];\n      } else {\n        // The token doesn\u0027t exist, so create it\n        this.value \u003d setValue(this, token, {});\n      }\n    }\n\n    // Set the value of the final token\n    resolveIf$Ref(this, options);\n    token \u003d tokens[tokens.length - 1];\n    setValue(this, token, value);\n\n    // Return the updated object\n    return obj;\n  }\n\n  /**\n   * Parses a JSON pointer (or a path containing a JSON pointer in the hash)\n   * and returns an array of the pointer\u0027s tokens.\n   * (e.g. \"schema.json#/definitions/person/name\" \u003d\u003e [\"definitions\", \"person\", \"name\"])\n   *\n   * The pointer is parsed according to RFC 6901\n   * {@link https://tools.ietf.org/html/rfc6901#section-3}\n   *\n   * @param path\n   * @param [originalPath]\n   * @returns\n   */\n  static parse(path: string, originalPath?: string): string[] {\n    // Get the JSON pointer from the path\u0027s hash\n    const pointer \u003d url.getHash(path).substring(1);\n\n    // If there\u0027s no pointer, then there are no tokens,\n    // so return an empty array\n    if (!pointer) {\n      return [];\n    }\n\n    // Split into an array\n    const split \u003d pointer.split(\"/\");\n\n    // Decode each part, according to RFC 6901\n    for (let i \u003d 0; i \u003c split.length; i++) {\n      split[i] \u003d safeDecodeURIComponent(split[i].replace(escapedSlash, \"/\").replace(escapedTilde, \"~\"));\n    }\n\n    if (split[0] !\u003d\u003d \"\") {\n      throw new InvalidPointerError(pointer, originalPath \u003d\u003d\u003d undefined ? path : originalPath);\n    }\n\n    return split.slice(1);\n  }\n\n  /**\n   * Creates a JSON pointer path, by joining one or more tokens to a base path.\n   *\n   * @param base - The base path (e.g. \"schema.json#/definitions/person\")\n   * @param tokens - The token(s) to append (e.g. [\"name\", \"first\"])\n   * @returns\n   */\n  static join(base: string, tokens: string | string[]) {\n    // Ensure that the base path contains a hash\n    if (base.indexOf(\"#\") \u003d\u003d\u003d -1) {\n      base +\u003d \"#\";\n    }\n\n    // Append each token to the base path\n    tokens \u003d Array.isArray(tokens) ? tokens : [tokens];\n    for (let i \u003d 0; i \u003c tokens.length; i++) {\n      const token \u003d tokens[i];\n      // Encode the token, according to RFC 6901\n      base +\u003d \"/\" + encodeURIComponent(token.replace(tildes, \"~0\").replace(slashes, \"~1\"));\n    }\n\n    return base;\n  }\n}\n\n/**\n * If the given pointer\u0027s {@link Pointer#value} is a JSON reference,\n * then the reference is resolved and {@link Pointer#value} is replaced with the resolved value.\n * In addition, {@link Pointer#path} and {@link Pointer#$ref} are updated to reflect the\n * resolution path of the new value.\n *\n * @param pointer\n * @param options\n * @param [pathFromRoot] - the path of place that initiated resolving\n * @returns - Returns `true` if the resolution path changed\n */\nfunction resolveIf$Ref(pointer: any, options: any, pathFromRoot?: any) {\n  // Is the value a JSON reference? (and allowed?)\n\n  if ($Ref.isAllowed$Ref(pointer.value, options)) {\n    const $refPath \u003d url.resolve(pointer.path, pointer.value.$ref);\n\n    if ($refPath \u003d\u003d\u003d pointer.path \u0026\u0026 !isRootPath(pathFromRoot)) {\n      // The value is a reference to itself, so there\u0027s nothing to do.\n      pointer.circular \u003d true;\n    } else {\n      const resolved \u003d pointer.$ref.$refs._resolve($refPath, pointer.path, options);\n      if (resolved \u003d\u003d\u003d null) {\n        return false;\n      }\n\n      pointer.indirections +\u003d resolved.indirections + 1;\n\n      if ($Ref.isExtended$Ref(pointer.value)) {\n        // This JSON reference \"extends\" the resolved value, rather than simply pointing to it.\n        // So the resolved path does NOT change.  Just the value does.\n        pointer.value \u003d $Ref.dereference(pointer.value, resolved.value);\n        return false;\n      } else {\n        // Resolve the reference\n        pointer.$ref \u003d resolved.$ref;\n        pointer.path \u003d resolved.path;\n        pointer.value \u003d resolved.value;\n      }\n\n      return true;\n    }\n  }\n  return undefined;\n}\nexport default Pointer;\n\n/**\n * Sets the specified token value of the {@link Pointer#value}.\n *\n * The token is evaluated according to RFC 6901.\n * {@link https://tools.ietf.org/html/rfc6901#section-4}\n *\n * @param pointer - The JSON Pointer whose value will be modified\n * @param token - A JSON Pointer token that indicates how to modify `obj`\n * @param value - The value to assign\n * @returns - Returns the assigned value\n */\nfunction setValue(pointer: any, token: any, value: any) {\n  if (pointer.value \u0026\u0026 typeof pointer.value \u003d\u003d\u003d \"object\") {\n    if (token \u003d\u003d\u003d \"-\" \u0026\u0026 Array.isArray(pointer.value)) {\n      pointer.value.push(value);\n    } else {\n      pointer.value[token] \u003d value;\n    }\n  } else {\n    throw new JSONParserError(\n      `Error assigning $ref pointer \"${pointer.path}\". \\nCannot set \"${token}\" of a non-object.`,\n    );\n  }\n  return value;\n}\n\nfunction unwrapOrThrow(value: any) {\n  if (isHandledError(value)) {\n    throw value;\n  }\n\n  return value;\n}\n\nfunction isRootPath(pathFromRoot: any): boolean {\n  return typeof pathFromRoot \u003d\u003d \"string\" \u0026\u0026 Pointer.parse(pathFromRoot).length \u003d\u003d 0;\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/ref.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport Pointer from \"./pointer.js\";\nimport type { JSONParserError, MissingPointerError, ParserError, ResolverError } from \"./util/errors.js\";\nimport { InvalidPointerError, isHandledError, normalizeError } from \"./util/errors.js\";\nimport { safePointerToPath, stripHash, getHash } from \"./util/url.js\";\nimport type $Refs from \"./refs.js\";\nimport type { ParserOptions } from \"./options.js\";\nimport type { JSONSchema } from \"./types\";\n\nexport type $RefError \u003d JSONParserError | ResolverError | ParserError | MissingPointerError;\n\n/**\n * This class represents a single JSON reference and its resolved value.\n *\n * @class\n */\nclass $Ref\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e {\n  /**\n   * The file path or URL of the referenced file.\n   * This path is relative to the path of the main JSON schema file.\n   *\n   * This path does NOT contain document fragments (JSON pointers). It always references an ENTIRE file.\n   * Use methods such as {@link $Ref#get}, {@link $Ref#resolve}, and {@link $Ref#exists} to get\n   * specific JSON pointers within the file.\n   *\n   * @type {string}\n   */\n  path: undefined | string;\n\n  /**\n   * The resolved value of the JSON reference.\n   * Can be any JSON type, not just objects. Unknown file types are represented as Buffers (byte arrays).\n   *\n   * @type {?*}\n   */\n  value: any;\n\n  /**\n   * The {@link $Refs} object that contains this {@link $Ref} object.\n   *\n   * @type {$Refs}\n   */\n  $refs: $Refs\u003cS, O\u003e;\n\n  /**\n   * Indicates the type of {@link $Ref#path} (e.g. \"file\", \"http\", etc.)\n   */\n  pathType: string | unknown;\n\n  /**\n   * List of all errors. Undefined if no errors.\n   */\n  errors: Array\u003c$RefError\u003e \u003d [];\n\n  constructor($refs: $Refs\u003cS, O\u003e) {\n    this.$refs \u003d $refs;\n  }\n\n  /**\n   * Pushes an error to errors array.\n   *\n   * @param err - The error to be pushed\n   * @returns\n   */\n  addError(err: $RefError) {\n    if (this.errors \u003d\u003d\u003d undefined) {\n      this.errors \u003d [];\n    }\n\n    const existingErrors \u003d this.errors.map(({ footprint }: any) \u003d\u003e footprint);\n\n    // the path has been almost certainly set at this point,\n    // but just in case something went wrong, normalizeError injects path if necessary\n    // moreover, certain errors might point at the same spot, so filter them out to reduce noise\n    if (\"errors\" in err \u0026\u0026 Array.isArray(err.errors)) {\n      this.errors.push(\n        ...err.errors.map(normalizeError).filter(({ footprint }: any) \u003d\u003e !existingErrors.includes(footprint)),\n      );\n    } else if (!(\"footprint\" in err) || !existingErrors.includes(err.footprint)) {\n      this.errors.push(normalizeError(err));\n    }\n  }\n\n  /**\n   * Determines whether the given JSON reference exists within this {@link $Ref#value}.\n   *\n   * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n   * @param options\n   * @returns\n   */\n  exists(path: string, options?: O) {\n    try {\n      this.resolve(path, options);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Resolves the given JSON reference within this {@link $Ref#value} and returns the resolved value.\n   *\n   * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n   * @param options\n   * @returns - Returns the resolved value\n   */\n  get(path: string, options?: O) {\n    return this.resolve(path, options)?.value;\n  }\n\n  /**\n   * Resolves the given JSON reference within this {@link $Ref#value}.\n   *\n   * @param path - The full path being resolved, optionally with a JSON pointer in the hash\n   * @param options\n   * @param friendlyPath - The original user-specified path (used for error messages)\n   * @param pathFromRoot - The path of `obj` from the schema root\n   * @returns\n   */\n  resolve(path: string, options?: O, friendlyPath?: string, pathFromRoot?: string) {\n    const pointer \u003d new Pointer\u003cS, O\u003e(this, path, friendlyPath);\n    try {\n      return pointer.resolve(this.value, options, pathFromRoot);\n    } catch (err: any) {\n      if (!options || !options.continueOnError || !isHandledError(err)) {\n        throw err;\n      }\n\n      if (err.path \u003d\u003d\u003d null) {\n        err.path \u003d safePointerToPath(getHash(pathFromRoot));\n      }\n\n      if (err instanceof InvalidPointerError) {\n        err.source \u003d decodeURI(stripHash(pathFromRoot));\n      }\n\n      this.addError(err);\n      return null;\n    }\n  }\n\n  /**\n   * Sets the value of a nested property within this {@link $Ref#value}.\n   * If the property, or any of its parents don\u0027t exist, they will be created.\n   *\n   * @param path - The full path of the property to set, optionally with a JSON pointer in the hash\n   * @param value - The value to assign\n   */\n  set(path: string, value: any) {\n    const pointer \u003d new Pointer(this, path);\n    this.value \u003d pointer.set(this.value, value);\n  }\n\n  /**\n   * Determines whether the given value is a JSON reference.\n   *\n   * @param value - The value to inspect\n   * @returns\n   */\n  static is$Ref(value: unknown): value is { $ref: string; length?: number } {\n    return (\n      Boolean(value) \u0026\u0026\n      typeof value \u003d\u003d\u003d \"object\" \u0026\u0026\n      value !\u003d\u003d null \u0026\u0026\n      \"$ref\" in value \u0026\u0026\n      typeof value.$ref \u003d\u003d\u003d \"string\" \u0026\u0026\n      value.$ref.length \u003e 0\n    );\n  }\n\n  /**\n   * Determines whether the given value is an external JSON reference.\n   *\n   * @param value - The value to inspect\n   * @returns\n   */\n  static isExternal$Ref(value: unknown): boolean {\n    return $Ref.is$Ref(value) \u0026\u0026 value.$ref![0] !\u003d\u003d \"#\";\n  }\n\n  /**\n   * Determines whether the given value is a JSON reference, and whether it is allowed by the options.\n   * For example, if it references an external file, then options.resolve.external must be true.\n   *\n   * @param value - The value to inspect\n   * @param options\n   * @returns\n   */\n  static isAllowed$Ref\u003cS extends object \u003d JSONSchema\u003e(value: unknown, options?: ParserOptions\u003cS\u003e) {\n    if (this.is$Ref(value)) {\n      if (value.$ref.substring(0, 2) \u003d\u003d\u003d \"#/\" || value.$ref \u003d\u003d\u003d \"#\") {\n        // It\u0027s a JSON Pointer reference, which is always allowed\n        return true;\n      } else if (value.$ref[0] !\u003d\u003d \"#\" \u0026\u0026 (!options || options.resolve?.external)) {\n        // It\u0027s an external reference, which is allowed by the options\n        return true;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Determines whether the given value is a JSON reference that \"extends\" its resolved value.\n   * That is, it has extra properties (in addition to \"$ref\"), so rather than simply pointing to\n   * an existing value, this $ref actually creates a NEW value that is a shallow copy of the resolved\n   * value, plus the extra properties.\n   *\n   * @example: {\n     person: {\n       properties: {\n         firstName: { type: string }\n         lastName: { type: string }\n       }\n     }\n     employee: {\n       properties: {\n         $ref: #/person/properties\n         salary: { type: number }\n       }\n     }\n   }\n   *  In this example, \"employee\" is an extended $ref, since it extends \"person\" with an additional\n   *  property (salary).  The result is a NEW value that looks like this:\n   *\n   *  {\n   *    properties: {\n   *      firstName: { type: string }\n   *      lastName: { type: string }\n   *      salary: { type: number }\n   *    }\n   *  }\n   *\n   * @param value - The value to inspect\n   * @returns\n   */\n  static isExtended$Ref(value: unknown) {\n    return $Ref.is$Ref(value) \u0026\u0026 Object.keys(value).length \u003e 1;\n  }\n\n  /**\n   * Returns the resolved value of a JSON Reference.\n   * If necessary, the resolved value is merged with the JSON Reference to create a new object\n   *\n   * @example: {\n  person: {\n    properties: {\n      firstName: { type: string }\n      lastName: { type: string }\n    }\n  }\n  employee: {\n    properties: {\n      $ref: #/person/properties\n      salary: { type: number }\n    }\n  }\n  } When \"person\" and \"employee\" are merged, you end up with the following object:\n   *\n   *  {\n   *    properties: {\n   *      firstName: { type: string }\n   *      lastName: { type: string }\n   *      salary: { type: number }\n   *    }\n   *  }\n   *\n   * @param $ref - The JSON reference object (the one with the \"$ref\" property)\n   * @param resolvedValue - The resolved value, which can be any type\n   * @returns - Returns the dereferenced value\n   */\n  static dereference\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    $ref: $Ref\u003cS, O\u003e,\n    resolvedValue: S,\n  ): S {\n    if (resolvedValue \u0026\u0026 typeof resolvedValue \u003d\u003d\u003d \"object\" \u0026\u0026 $Ref.isExtended$Ref($ref)) {\n      const merged \u003d {};\n      for (const key of Object.keys($ref)) {\n        if (key !\u003d\u003d \"$ref\") {\n          // @ts-expect-error TS(7053): Element implicitly has an \u0027any\u0027 type because expre... Remove this comment to see the full error message\n          merged[key] \u003d $ref[key];\n        }\n      }\n\n      for (const key of Object.keys(resolvedValue)) {\n        if (!(key in merged)) {\n          // @ts-expect-error TS(7053): Element implicitly has an \u0027any\u0027 type because expre... Remove this comment to see the full error message\n          merged[key] \u003d resolvedValue[key];\n        }\n      }\n\n      return merged as S;\n    } else {\n      // Completely replace the original reference with the resolved value\n      return resolvedValue;\n    }\n  }\n}\n\nexport default $Ref;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/refs.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport { ono } from \"@jsdevtools/ono\";\nimport $Ref from \"./ref.js\";\nimport * as url from \"./util/url.js\";\nimport type { JSONSchema4Type, JSONSchema6Type, JSONSchema7Type } from \"json-schema\";\nimport type { ParserOptions } from \"./options.js\";\nimport convertPathToPosix from \"./util/convert-path-to-posix\";\nimport type { JSONSchema } from \"./types\";\n\ninterface $RefsMap\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e {\n  [url: string]: $Ref\u003cS, O\u003e;\n}\n/**\n * When you call the resolve method, the value that gets passed to the callback function (or Promise) is a $Refs object. This same object is accessible via the parser.$refs property of $RefParser objects.\n *\n * This object is a map of JSON References and their resolved values. It also has several convenient helper methods that make it easy for you to navigate and manipulate the JSON References.\n *\n * See https://apitools.dev/json-schema-ref-parser/docs/refs.html\n */\nexport default class $Refs\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e {\n  /**\n   * This property is true if the schema contains any circular references. You may want to check this property before serializing the dereferenced schema as JSON, since JSON.stringify() does not support circular references by default.\n   *\n   * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#circular\n   */\n  public circular: boolean;\n\n  /**\n   * Returns the paths/URLs of all the files in your schema (including the main schema file).\n   *\n   * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#pathstypes\n   *\n   * @param types (optional) Optionally only return certain types of paths (\"file\", \"http\", etc.)\n   */\n  paths(...types: (string | string[])[]): string[] {\n    const paths \u003d getPaths(this._$refs, types.flat());\n    return paths.map((path) \u003d\u003e {\n      return convertPathToPosix(path.decoded);\n    });\n  }\n\n  /**\n   * Returns a map of paths/URLs and their correspond values.\n   *\n   * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#valuestypes\n   *\n   * @param types (optional) Optionally only return values from certain locations (\"file\", \"http\", etc.)\n   */\n  values(...types: (string | string[])[]): S {\n    const $refs \u003d this._$refs;\n    const paths \u003d getPaths($refs, types.flat());\n    return paths.reduce\u003cRecord\u003cstring, any\u003e\u003e((obj, path) \u003d\u003e {\n      obj[convertPathToPosix(path.decoded)] \u003d $refs[path.encoded].value;\n      return obj;\n    }, {}) as S;\n  }\n\n  /**\n   * Returns `true` if the given path exists in the schema; otherwise, returns `false`\n   *\n   * See https://apitools.dev/json-schema-ref-parser/docs/refs.html#existsref\n   *\n   * @param $ref The JSON Reference path, optionally with a JSON Pointer in the hash\n   */\n  /**\n   * Determines whether the given JSON reference exists.\n   *\n   * @param path - The path being resolved, optionally with a JSON pointer in the hash\n   * @param [options]\n   * @returns\n   */\n  exists(path: string, options: any) {\n    try {\n      this._resolve(path, \"\", options);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Resolves the given JSON reference and returns the resolved value.\n   *\n   * @param path - The path being resolved, with a JSON pointer in the hash\n   * @param [options]\n   * @returns - Returns the resolved value\n   */\n  get(path: string, options?: O): JSONSchema4Type | JSONSchema6Type | JSONSchema7Type {\n    return this._resolve(path, \"\", options)!.value;\n  }\n\n  /**\n   * Sets the value at the given path in the schema. If the property, or any of its parents, don\u0027t exist, they will be created.\n   *\n   * @param path The JSON Reference path, optionally with a JSON Pointer in the hash\n   * @param value The value to assign. Can be anything (object, string, number, etc.)\n   */\n  set(path: string, value: JSONSchema4Type | JSONSchema6Type | JSONSchema7Type) {\n    const absPath \u003d url.resolve(this._root$Ref.path!, path);\n    const withoutHash \u003d url.stripHash(absPath);\n    const $ref \u003d this._$refs[withoutHash];\n\n    if (!$ref) {\n      throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n    }\n\n    $ref.set(absPath, value);\n  }\n  /**\n   * Returns the specified {@link $Ref} object, or undefined.\n   *\n   * @param path - The path being resolved, optionally with a JSON pointer in the hash\n   * @returns\n   * @protected\n   */\n  _get$Ref(path: string) {\n    path \u003d url.resolve(this._root$Ref.path!, path);\n    const withoutHash \u003d url.stripHash(path);\n    return this._$refs[withoutHash];\n  }\n\n  /**\n   * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\n   *\n   * @param path  - The file path or URL of the referenced file\n   */\n  _add(path: string) {\n    const withoutHash \u003d url.stripHash(path);\n\n    const $ref \u003d new $Ref\u003cS, O\u003e(this);\n    $ref.path \u003d withoutHash;\n\n    this._$refs[withoutHash] \u003d $ref;\n    this._root$Ref \u003d this._root$Ref || $ref;\n\n    return $ref;\n  }\n\n  /**\n   * Resolves the given JSON reference.\n   *\n   * @param path - The path being resolved, optionally with a JSON pointer in the hash\n   * @param pathFromRoot - The path of `obj` from the schema root\n   * @param [options]\n   * @returns\n   * @protected\n   */\n  _resolve(path: string, pathFromRoot: string, options?: O) {\n    const absPath \u003d url.resolve(this._root$Ref.path!, path);\n    const withoutHash \u003d url.stripHash(absPath);\n    const $ref \u003d this._$refs[withoutHash];\n\n    if (!$ref) {\n      throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n    }\n\n    return $ref.resolve(absPath, options, path, pathFromRoot);\n  }\n\n  /**\n   * A map of paths/urls to {@link $Ref} objects\n   *\n   * @type {object}\n   * @protected\n   */\n  _$refs: $RefsMap\u003cS, O\u003e \u003d {};\n\n  /**\n   * The {@link $Ref} object that is the root of the JSON schema.\n   *\n   * @type {$Ref}\n   * @protected\n   */\n  _root$Ref: $Ref\u003cS, O\u003e;\n\n  constructor() {\n    /**\n     * Indicates whether the schema contains any circular references.\n     *\n     * @type {boolean}\n     */\n    this.circular \u003d false;\n\n    this._$refs \u003d {};\n\n    // @ts-ignore\n    this._root$Ref \u003d null;\n  }\n\n  /**\n   * Returns the paths of all the files/URLs that are referenced by the JSON schema,\n   * including the schema itself.\n   *\n   * @param [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n   * @returns\n   */\n  /**\n   * Returns the map of JSON references and their resolved values.\n   *\n   * @param [types] - Only return references of the given types (\"file\", \"http\", etc.)\n   * @returns\n   */\n\n  /**\n   * Returns a POJO (plain old JavaScript object) for serialization as JSON.\n   *\n   * @returns {object}\n   */\n  toJSON \u003d this.values;\n}\n\n/**\n * Returns the encoded and decoded paths keys of the given object.\n *\n * @param $refs - The object whose keys are URL-encoded paths\n * @param [types] - Only return paths of the given types (\"file\", \"http\", etc.)\n * @returns\n */\nfunction getPaths\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  $refs: $RefsMap\u003cS, O\u003e,\n  types: string[],\n) {\n  let paths \u003d Object.keys($refs);\n\n  // Filter the paths by type\n  types \u003d Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n  if (types.length \u003e 0 \u0026\u0026 types[0]) {\n    paths \u003d paths.filter((key) \u003d\u003e {\n      return types.includes($refs[key].pathType as string);\n    });\n  }\n\n  // Decode local filesystem paths\n  return paths.map((path) \u003d\u003e {\n    return {\n      encoded: path,\n      decoded: $refs[path].pathType \u003d\u003d\u003d \"file\" ? url.toFileSystemPath(path, true) : path,\n    };\n  });\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/resolve-external.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport $Ref from \"./ref.js\";\nimport Pointer from \"./pointer.js\";\nimport parse from \"./parse.js\";\nimport * as url from \"./util/url.js\";\nimport { isHandledError } from \"./util/errors.js\";\nimport type $Refs from \"./refs.js\";\nimport type { ParserOptions } from \"./options.js\";\nimport type { JSONSchema } from \"./types/index.js\";\nimport type $RefParser from \"./index.js\";\n\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @returns\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nfunction resolveExternal\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  parser: $RefParser\u003cS, O\u003e,\n  options: O,\n) {\n  if (!options.resolve?.external) {\n    // Nothing to resolve, so exit early\n    return Promise.resolve();\n  }\n\n  try {\n    // console.log(\u0027Resolving $ref pointers in %s\u0027, parser.$refs._root$Ref.path);\n    const promises \u003d crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n    return Promise.all(promises);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param obj - The value to crawl. If it\u0027s not an object or array, it will be ignored.\n * @param path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {boolean} external - Whether `obj` was found in an external document.\n * @param $refs\n * @param options\n * @param seen - Internal.\n *\n * @returns\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\nfunction crawl\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  obj: string | Buffer | S | undefined | null,\n  path: string,\n  $refs: $Refs\u003cS, O\u003e,\n  options: O,\n  seen?: Set\u003cany\u003e,\n  external?: boolean,\n) {\n  seen ||\u003d new Set();\n  let promises: any \u003d [];\n\n  if (obj \u0026\u0026 typeof obj \u003d\u003d\u003d \"object\" \u0026\u0026 !ArrayBuffer.isView(obj) \u0026\u0026 !seen.has(obj)) {\n    seen.add(obj); // Track previously seen objects to avoid infinite recursion\n    if ($Ref.isExternal$Ref(obj)) {\n      promises.push(resolve$Ref\u003cS, O\u003e(obj, path, $refs, options));\n    }\n\n    const keys \u003d Object.keys(obj) as string[];\n    for (const key of keys) {\n      const keyPath \u003d Pointer.join(path, key);\n      const value \u003d obj[key as keyof typeof obj] as string | JSONSchema | Buffer | undefined;\n      promises \u003d promises.concat(crawl(value, keyPath, $refs, options, seen, external));\n    }\n  }\n\n  return promises;\n}\n\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param $ref - The JSON Reference to resolve\n * @param path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param $refs\n * @param options\n *\n * @returns\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\nasync function resolve$Ref\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  $ref: S,\n  path: string,\n  $refs: $Refs\u003cS, O\u003e,\n  options: O,\n) {\n  const shouldResolveOnCwd \u003d options.dereference?.externalReferenceResolution \u003d\u003d\u003d \"root\";\n  const resolvedPath \u003d url.resolve(shouldResolveOnCwd ? url.cwd() : path, ($ref as JSONSchema).$ref!);\n  const withoutHash \u003d url.stripHash(resolvedPath);\n\n  // $ref.$ref \u003d url.relative($refs._root$Ref.path, resolvedPath);\n\n  // Do we already have this $ref?\n  const ref \u003d $refs._$refs[withoutHash];\n  if (ref) {\n    // We\u0027ve already parsed this $ref, so use the existing value\n    return Promise.resolve(ref.value);\n  }\n\n  // Parse the $referenced file/url\n  try {\n    const result \u003d await parse(resolvedPath, $refs, options);\n\n    // Crawl the parsed value\n    // console.log(\u0027Resolving $ref pointers in %s\u0027, withoutHash);\n    const promises \u003d crawl(result, withoutHash + \"#\", $refs, options, new Set(), true);\n\n    return Promise.all(promises);\n  } catch (err) {\n    if (!options?.continueOnError || !isHandledError(err)) {\n      throw err;\n    }\n\n    if ($refs._$refs[withoutHash]) {\n      err.source \u003d decodeURI(url.stripHash(path));\n      err.path \u003d url.safePointerToPath(url.getHash(path));\n    }\n\n    return [];\n  }\n}\nexport default resolveExternal;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/parsers/binary.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport type { FileInfo } from \"../types/index.js\";\nimport type { Plugin } from \"../types/index.js\";\n\nconst BINARY_REGEXP \u003d /\\.(jpeg|jpg|gif|png|bmp|ico)$/i;\n\nexport default {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   */\n  order: 400,\n\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   */\n  allowEmpty: true,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   */\n  canParse(file: FileInfo) {\n    // Use this parser if the file is a Buffer, and has a known binary extension\n    return Buffer.isBuffer(file.data) \u0026\u0026 BINARY_REGEXP.test(file.url);\n  },\n\n  /**\n   * Parses the given data as a Buffer (byte array).\n   */\n  parse(file: FileInfo) {\n    if (Buffer.isBuffer(file.data)) {\n      return file.data;\n    } else {\n      // This will reject if data is anything other than a string or typed array\n      return Buffer.from(file.data);\n    }\n  },\n} as Plugin;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/parsers/json.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport { ParserError } from \"../util/errors.js\";\nimport type { FileInfo } from \"../types/index.js\";\nimport type { Plugin } from \"../types/index.js\";\n\nexport default {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   */\n  order: 100,\n\n  /**\n   * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n   */\n  allowEmpty: true,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that match will be tried, in order, until one successfully parses the file.\n   * Parsers that don\u0027t match will be skipped, UNLESS none of the parsers match, in which case\n   * every parser will be tried.\n   */\n  canParse: \".json\",\n\n  /**\n   * Allow JSON files with byte order marks (BOM)\n   */\n  allowBOM: true,\n\n  /**\n   * Parses the given file as JSON\n   */\n  async parse(file: FileInfo): Promise\u003cobject | undefined\u003e {\n    let data \u003d file.data;\n    if (Buffer.isBuffer(data)) {\n      data \u003d data.toString();\n    }\n\n    if (typeof data \u003d\u003d\u003d \"string\") {\n      if (data.trim().length \u003d\u003d\u003d 0) {\n        return; // This mirrors the YAML behavior\n      } else {\n        try {\n          return JSON.parse(data);\n        } catch (e: any) {\n          if (this.allowBOM) {\n            try {\n              // find the first curly brace\n              const firstCurlyBrace \u003d data.indexOf(\"{\");\n              // remove any characters before the first curly brace\n              data \u003d data.slice(firstCurlyBrace);\n              return JSON.parse(data);\n            } catch (e: any) {\n              throw new ParserError(e.message, file.url);\n            }\n          }\n          throw new ParserError(e.message, file.url);\n        }\n      }\n    } else {\n      // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n      return data as object;\n    }\n  },\n} as Plugin;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/parsers/text.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport { ParserError } from \"../util/errors.js\";\nimport type { FileInfo } from \"../types/index.js\";\nimport type { Plugin } from \"../types/index.js\";\n\nconst TEXT_REGEXP \u003d /\\.(txt|htm|html|md|xml|js|min|map|css|scss|less|svg)$/i;\n\nexport default {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   */\n  order: 300,\n\n  /**\n   * Whether to allow \"empty\" files (zero bytes).\n   */\n  allowEmpty: true,\n\n  /**\n   * The encoding that the text is expected to be in.\n   */\n  encoding: \"utf8\" as BufferEncoding,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that return true will be tried, in order, until one successfully parses the file.\n   * Parsers that return false will be skipped, UNLESS all parsers returned false, in which case\n   * every parser will be tried.\n   */\n  canParse(file: FileInfo) {\n    // Use this parser if the file is a string or Buffer, and has a known text-based extension\n    return (typeof file.data \u003d\u003d\u003d \"string\" || Buffer.isBuffer(file.data)) \u0026\u0026 TEXT_REGEXP.test(file.url);\n  },\n\n  /**\n   * Parses the given file as text\n   */\n  parse(file: FileInfo) {\n    if (typeof file.data \u003d\u003d\u003d \"string\") {\n      return file.data;\n    } else if (Buffer.isBuffer(file.data)) {\n      return file.data.toString(this.encoding);\n    } else {\n      throw new ParserError(\"data is not text\", file.url);\n    }\n  },\n} as Plugin;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/parsers/yaml.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport { ParserError } from \"../util/errors.js\";\nimport yaml from \"js-yaml\";\nimport { JSON_SCHEMA } from \"js-yaml\";\nimport type { FileInfo } from \"../types/index.js\";\nimport type { Plugin } from \"../types/index.js\";\n\nexport default {\n  /**\n   * The order that this parser will run, in relation to other parsers.\n   */\n  order: 200,\n\n  /**\n   * Whether to allow \"empty\" files. This includes zero-byte files, as well as empty JSON objects.\n   */\n  allowEmpty: true,\n\n  /**\n   * Determines whether this parser can parse a given file reference.\n   * Parsers that match will be tried, in order, until one successfully parses the file.\n   * Parsers that don\u0027t match will be skipped, UNLESS none of the parsers match, in which case\n   * every parser will be tried.\n   */\n  canParse: [\".yaml\", \".yml\", \".json\"], // JSON is valid YAML\n\n  /**\n   * Parses the given file as YAML\n   *\n   * @param file           - An object containing information about the referenced file\n   * @param file.url       - The full URL of the referenced file\n   * @param file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n   * @param file.data      - The file contents. This will be whatever data type was returned by the resolver\n   * @returns\n   */\n  async parse(file: FileInfo) {\n    let data \u003d file.data;\n    if (Buffer.isBuffer(data)) {\n      data \u003d data.toString();\n    }\n\n    if (typeof data \u003d\u003d\u003d \"string\") {\n      try {\n        return yaml.load(data, { schema: JSON_SCHEMA });\n      } catch (e: any) {\n        throw new ParserError(e?.message || \"Parser Error\", file.url);\n      }\n    } else {\n      // data is already a JavaScript value (object, array, number, null, NaN, etc.)\n      return data;\n    }\n  },\n} as Plugin;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/resolvers/file.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport fs from \"fs\";\nimport { ono } from \"@jsdevtools/ono\";\nimport * as url from \"../util/url.js\";\nimport { ResolverError } from \"../util/errors.js\";\nimport type { JSONSchema, ResolverOptions } from \"../types/index.js\";\nimport type { FileInfo } from \"../types/index.js\";\n\nexport default {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   */\n  order: 100,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried, in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   */\n  canRead(file: FileInfo) {\n    return url.isFileSystemPath(file.url);\n  },\n\n  /**\n   * Reads the given file and returns its raw contents as a Buffer.\n   */\n  async read(file: FileInfo): Promise\u003cBuffer\u003e {\n    let path: string | undefined;\n    try {\n      path \u003d url.toFileSystemPath(file.url);\n    } catch (err: any) {\n      throw new ResolverError(ono.uri(err, `Malformed URI: ${file.url}`), file.url);\n    }\n    try {\n      return await fs.promises.readFile(path);\n    } catch (err: any) {\n      throw new ResolverError(ono(err, `Error opening file \"${path}\"`), path);\n    }\n  },\n} as ResolverOptions\u003cJSONSchema\u003e;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/resolvers/http.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport { ono } from \"@jsdevtools/ono\";\nimport * as url from \"../util/url.js\";\nimport { ResolverError } from \"../util/errors.js\";\nimport type { FileInfo, HTTPResolverOptions, JSONSchema } from \"../types/index.js\";\n\nexport default {\n  /**\n   * The order that this resolver will run, in relation to other resolvers.\n   */\n  order: 200,\n\n  /**\n   * HTTP headers to send when downloading files.\n   *\n   * @example:\n   * {\n   *   \"User-Agent\": \"JSON Schema $Ref Parser\",\n   *   Accept: \"application/json\"\n   * }\n   */\n  headers: null,\n\n  /**\n   * HTTP request timeout (in milliseconds).\n   */\n  timeout: 60_000, // 60 seconds\n\n  /**\n   * The maximum number of HTTP redirects to follow.\n   * To disable automatic following of redirects, set this to zero.\n   */\n  redirects: 5,\n\n  /**\n   * The `withCredentials` option of XMLHttpRequest.\n   * Set this to `true` if you\u0027re downloading files from a CORS-enabled server that requires authentication\n   */\n  withCredentials: false,\n\n  /**\n   * Determines whether this resolver can read a given file reference.\n   * Resolvers that return true will be tried in order, until one successfully resolves the file.\n   * Resolvers that return false will not be given a chance to resolve the file.\n   */\n  canRead(file: FileInfo) {\n    return url.isHttp(file.url);\n  },\n\n  /**\n   * Reads the given URL and returns its raw contents as a Buffer.\n   */\n  read(file: FileInfo) {\n    const u \u003d url.parse(file.url);\n\n    if (typeof window !\u003d\u003d \"undefined\" \u0026\u0026 !u.protocol) {\n      // Use the protocol of the current page\n      u.protocol \u003d url.parse(location.href).protocol;\n    }\n\n    return download(u, this);\n  },\n} as HTTPResolverOptions\u003cJSONSchema\u003e;\n\n/**\n * Downloads the given file.\n * @returns\n * The promise resolves with the raw downloaded data, or rejects if there is an HTTP error.\n */\nasync function download\u003cS extends object \u003d JSONSchema\u003e(\n  u: URL | string,\n  httpOptions: HTTPResolverOptions\u003cS\u003e,\n  _redirects?: string[],\n): Promise\u003cBuffer\u003e {\n  u \u003d url.parse(u);\n  const redirects \u003d _redirects || [];\n  redirects.push(u.href);\n\n  try {\n    const res \u003d await get(u, httpOptions);\n    if (res.status \u003e\u003d 400) {\n      throw ono({ status: res.status }, `HTTP ERROR ${res.status}`);\n    } else if (res.status \u003e\u003d 300) {\n      if (!Number.isNaN(httpOptions.redirects) \u0026\u0026 redirects.length \u003e httpOptions.redirects!) {\n        throw new ResolverError(\n          ono(\n            { status: res.status },\n            `Error downloading ${redirects[0]}. \\nToo many redirects: \\n  ${redirects.join(\" \\n  \")}`,\n          ),\n        );\n      } else if (!(\"location\" in res.headers) || !res.headers.location) {\n        throw ono({ status: res.status }, `HTTP ${res.status} redirect with no location header`);\n      } else {\n        const redirectTo \u003d url.resolve(u.href, res.headers.location as string);\n        return download(redirectTo, httpOptions, redirects);\n      }\n    } else {\n      if (res.body) {\n        const buf \u003d await res.arrayBuffer();\n        return Buffer.from(buf);\n      }\n      return Buffer.alloc(0);\n    }\n  } catch (err: any) {\n    throw new ResolverError(ono(err, `Error downloading ${u.href}`), u.href);\n  }\n}\n\n/**\n * Sends an HTTP GET request.\n * The promise resolves with the HTTP Response object.\n */\nasync function get\u003cS extends object \u003d JSONSchema\u003e(u: RequestInfo | URL, httpOptions: HTTPResolverOptions\u003cS\u003e) {\n  let controller: any;\n  let timeoutId: any;\n  if (httpOptions.timeout) {\n    controller \u003d new AbortController();\n    timeoutId \u003d setTimeout(() \u003d\u003e controller.abort(), httpOptions.timeout);\n  }\n\n  const response \u003d await fetch(u, {\n    method: \"GET\",\n    headers: httpOptions.headers || {},\n    credentials: httpOptions.withCredentials ? \"include\" : \"same-origin\",\n    signal: controller ? controller.signal : null,\n  });\n  if (timeoutId) {\n    clearTimeout(timeoutId);\n  }\n\n  return response;\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/types/index.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport type {\n  JSONSchema4,\n  JSONSchema4Object,\n  JSONSchema6,\n  JSONSchema6Object,\n  JSONSchema7,\n  JSONSchema7Object,\n} from \"json-schema\";\nimport type $Refs from \"../refs.js\";\nimport type { ParserOptions } from \"../options\";\n\nexport type JSONSchema \u003d JSONSchema4 | JSONSchema6 | JSONSchema7;\nexport type JSONSchemaObject \u003d JSONSchema4Object | JSONSchema6Object | JSONSchema7Object;\nexport type SchemaCallback\u003cS extends object \u003d JSONSchema\u003e \u003d (err: Error | null, schema?: S | object | null) \u003d\u003e any;\nexport type $RefsCallback\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e \u003d (\n  err: Error | null,\n  $refs?: $Refs\u003cS, O\u003e,\n) \u003d\u003e any;\n\n/**\n * See https://apitools.dev/json-schema-ref-parser/docs/options.html\n */\n\nexport interface HTTPResolverOptions\u003cS extends object \u003d JSONSchema\u003e extends Partial\u003cResolverOptions\u003cS\u003e\u003e {\n  /**\n   * You can specify any HTTP headers that should be sent when downloading files. For example, some servers may require you to set the `Accept` or `Referrer` header.\n   */\n  headers?: RequestInit[\"headers\"] | null;\n\n  /**\n   * The amount of time (in milliseconds) to wait for a response from the server when downloading files. The default is 5 seconds.\n   */\n  timeout?: number;\n\n  /**\n   * The maximum number of HTTP redirects to follow per file. The default is 5. To disable automatic following of redirects, set this to zero.\n   */\n  redirects?: number;\n\n  /**\n   * Set this to `true` if you\u0027re downloading files from a CORS-enabled server that requires authentication\n   */\n  withCredentials?: boolean;\n}\n\n/**\n * JSON Schema `$Ref` Parser comes with built-in resolvers for HTTP and HTTPS URLs, as well as local filesystem paths (when running in Node.js). You can add your own custom resolvers to support additional protocols, or even replace any of the built-in resolvers with your own custom implementation.\n *\n * See https://apitools.dev/json-schema-ref-parser/docs/plugins/resolvers.html\n */\nexport interface ResolverOptions\u003cS extends object \u003d JSONSchema\u003e {\n  name?: string;\n  /**\n   * All resolvers have an order property, even the built-in resolvers. If you don\u0027t specify an order property, then your resolver will run last. Specifying `order: 1`, like we did in this example, will make your resolver run first. Or you can squeeze your resolver in-between some of the built-in resolvers. For example, `order: 101` would make it run after the file resolver, but before the HTTP resolver. You can see the order of all the built-in resolvers by looking at their source code.\n   *\n   * The order property and canRead property are related to each other. For each file that JSON Schema $Ref Parser needs to resolve, it first determines which resolvers can read that file by checking their canRead property. If only one resolver matches a file, then only that one resolver is called, regardless of its order. If multiple resolvers match a file, then those resolvers are tried in order until one of them successfully reads the file. Once a resolver successfully reads the file, the rest of the resolvers are skipped.\n   */\n  order?: number;\n\n  /**\n   * The `canRead` property tells JSON Schema `$Ref` Parser what kind of files your resolver can read. In this example, we\u0027ve simply specified a regular expression that matches \"mogodb://\" URLs, but we could have used a simple boolean, or even a function with custom logic to determine which files to resolve. Here are examples of each approach:\n   */\n  canRead: boolean | RegExp | string | string[] | ((file: FileInfo) \u003d\u003e boolean);\n\n  /**\n   * This is where the real work of a resolver happens. The `read` method accepts the same file info object as the `canRead` function, but rather than returning a boolean value, the `read` method should return the contents of the file. The file contents should be returned in as raw a form as possible, such as a string or a byte array. Any further parsing or processing should be done by parsers.\n   *\n   * Unlike the `canRead` function, the `read` method can also be asynchronous. This might be important if your resolver needs to read data from a database or some other external source. You can return your asynchronous value using either an ES6 Promise or a Node.js-style error-first callback. Of course, if your resolver has the ability to return its data synchronously, then that\u0027s fine too. Here are examples of all three approaches:\n   */\n  read:\n    | string\n    | object\n    | ((\n        file: FileInfo,\n        callback?: (error: Error | null, data: string | null) \u003d\u003e any,\n      ) \u003d\u003e string | Buffer | S | Promise\u003cstring | Buffer | S\u003e);\n}\n\nexport interface Plugin {\n  name?: string;\n  /**\n   * Parsers run in a specific order, relative to other parsers. For example, a parser with `order: 5` will run before a parser with `order: 10`. If a parser is unable to successfully parse a file, then the next parser is tried, until one succeeds or they all fail.\n   *\n   * You can change the order in which parsers run, which is useful if you know that most of your referenced files will be a certain type, or if you add your own custom parser that you want to run first.\n   */\n  order?: number;\n\n  /**\n   * All of the built-in parsers allow empty files by default. The JSON and YAML parsers will parse empty files as `undefined`. The text parser will parse empty files as an empty string. The binary parser will parse empty files as an empty byte array.\n   *\n   * You can set `allowEmpty: false` on any parser, which will cause an error to be thrown if a file empty.\n   */\n  allowEmpty?: boolean;\n\n  /**\n   * Specifies whether a Byte Order Mark (BOM) is allowed or not. Only applies to JSON parsing\n   *\n   * @type {boolean} @default true\n   */\n  allowBOM?: boolean;\n\n  /**\n   * The encoding that the text is expected to be in.\n   */\n  encoding?: BufferEncoding;\n  /**\n   * Determines which parsers will be used for which files.\n   *\n   * A regular expression can be used to match files by their full path. A string (or array of strings) can be used to match files by their file extension. Or a function can be used to perform more complex matching logic. See the custom parser docs for details.\n   */\n  canParse?: boolean | RegExp | string | string[] | ((file: FileInfo) \u003d\u003e boolean);\n\n  /**\n   * This is where the real work of a parser happens. The `parse` method accepts the same file info object as the `canParse` function, but rather than returning a boolean value, the `parse` method should return a JavaScript representation of the file contents.  For our CSV parser, that is a two-dimensional array of lines and values.  For your parser, it might be an object, a string, a custom class, or anything else.\n   *\n   * Unlike the `canParse` function, the `parse` method can also be asynchronous. This might be important if your parser needs to retrieve data from a database or if it relies on an external HTTP service to return the parsed value.  You can return your asynchronous value via a [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) or a Node.js-style error-first callback.  Here are examples of both approaches:\n   */\n  parse:\n    | ((file: FileInfo, callback?: (error: Error | null, data: string | null) \u003d\u003e any) \u003d\u003e unknown | Promise\u003cunknown\u003e)\n    | number\n    | string;\n}\n\n/**\n * JSON Schema `$Ref` Parser supports plug-ins, such as resolvers and parsers. These plug-ins can have methods such as `canRead()`, `read()`, `canParse()`, and `parse()`. All of these methods accept the same object as their parameter: an object containing information about the file being read or parsed.\n *\n * The file info object currently only consists of a few properties, but it may grow in the future if plug-ins end up needing more information.\n *\n * See https://apitools.dev/json-schema-ref-parser/docs/plugins/file-info-object.html\n */\nexport interface FileInfo {\n  /**\n   * The full URL of the file. This could be any type of URL, including \"http://\", \"https://\", \"file://\", \"ftp://\", \"mongodb://\", or even a local filesystem path (when running in Node.js).\n   */\n  url: string;\n\n  /**\n   * The hash (URL fragment) of the file URL, including the # symbol. If the URL doesn\u0027t have a hash, then this will be an empty string.\n   */\n  hash: string;\n\n  /**\n   * The lowercase file extension, such as \".json\", \".yaml\", \".txt\", etc.\n   */\n  extension: string;\n\n  /**\n   * The raw file contents, in whatever form they were returned by the resolver that read the file.\n   */\n  data: string | Buffer;\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/util/convert-path-to-posix.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport path from \"path\";\n\nexport default function convertPathToPosix(filePath: string) {\n  const isExtendedLengthPath \u003d filePath.startsWith(\"\\\\\\\\?\\\\\");\n\n  if (isExtendedLengthPath) {\n    return filePath;\n  }\n\n  return filePath.split(path?.win32?.sep).join(path?.posix?.sep ?? \"/\");\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/util/errors.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport { Ono } from \"@jsdevtools/ono\";\nimport { getHash, stripHash, toFileSystemPath } from \"./url.js\";\nimport type $RefParser from \"../index.js\";\nimport type { ParserOptions } from \"../index.js\";\nimport type { JSONSchema } from \"../index.js\";\nimport type $Ref from \"../ref\";\n\nexport type JSONParserErrorType \u003d\n  | \"EUNKNOWN\"\n  | \"EPARSER\"\n  | \"EUNMATCHEDPARSER\"\n  | \"ETIMEOUT\"\n  | \"ERESOLVER\"\n  | \"EUNMATCHEDRESOLVER\"\n  | \"EMISSINGPOINTER\"\n  | \"EINVALIDPOINTER\";\n\nexport class JSONParserError extends Error {\n  public readonly name: string;\n  public readonly message: string;\n  public source: string | undefined;\n  public path: Array\u003cstring | number\u003e | null;\n  public readonly code: JSONParserErrorType;\n  public constructor(message: string, source?: string) {\n    super();\n\n    this.code \u003d \"EUNKNOWN\";\n    this.name \u003d \"JSONParserError\";\n    this.message \u003d message;\n    this.source \u003d source;\n    this.path \u003d null;\n\n    Ono.extend(this);\n  }\n\n  get footprint() {\n    return `${this.path}+${this.source}+${this.code}+${this.message}`;\n  }\n}\n\nexport class JSONParserErrorGroup\u003c\n  S extends object \u003d JSONSchema,\n  O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e,\n\u003e extends Error {\n  files: $RefParser\u003cS, O\u003e;\n\n  constructor(parser: $RefParser\u003cS, O\u003e) {\n    super();\n\n    this.files \u003d parser;\n    this.name \u003d \"JSONParserErrorGroup\";\n    this.message \u003d `${this.errors.length} error${\n      this.errors.length \u003e 1 ? \"s\" : \"\"\n    } occurred while reading \u0027${toFileSystemPath(parser.$refs._root$Ref!.path)}\u0027`;\n\n    Ono.extend(this);\n  }\n\n  static getParserErrors\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n    parser: $RefParser\u003cS, O\u003e,\n  ) {\n    const errors \u003d [];\n\n    for (const $ref of Object.values(parser.$refs._$refs) as $Ref\u003cS, O\u003e[]) {\n      if ($ref.errors) {\n        errors.push(...$ref.errors);\n      }\n    }\n\n    return errors;\n  }\n\n  get errors(): Array\u003c\n    | JSONParserError\n    | InvalidPointerError\n    | ResolverError\n    | ParserError\n    | MissingPointerError\n    | UnmatchedParserError\n    | UnmatchedResolverError\n  \u003e {\n    return JSONParserErrorGroup.getParserErrors\u003cS, O\u003e(this.files);\n  }\n}\n\nexport class ParserError extends JSONParserError {\n  code \u003d \"EPARSER\" as JSONParserErrorType;\n  name \u003d \"ParserError\";\n  constructor(message: any, source: any) {\n    super(`Error parsing ${source}: ${message}`, source);\n  }\n}\n\nexport class UnmatchedParserError extends JSONParserError {\n  code \u003d \"EUNMATCHEDPARSER\" as JSONParserErrorType;\n  name \u003d \"UnmatchedParserError\";\n\n  constructor(source: string) {\n    super(`Could not find parser for \"${source}\"`, source);\n  }\n}\n\nexport class ResolverError extends JSONParserError {\n  code \u003d \"ERESOLVER\" as JSONParserErrorType;\n  name \u003d \"ResolverError\";\n  ioErrorCode?: string;\n  constructor(ex: Error | any, source?: string) {\n    super(ex.message || `Error reading file \"${source}\"`, source);\n    if (\"code\" in ex) {\n      this.ioErrorCode \u003d String(ex.code);\n    }\n  }\n}\n\nexport class UnmatchedResolverError extends JSONParserError {\n  code \u003d \"EUNMATCHEDRESOLVER\" as JSONParserErrorType;\n  name \u003d \"UnmatchedResolverError\";\n  constructor(source: any) {\n    super(`Could not find resolver for \"${source}\"`, source);\n  }\n}\n\nexport class MissingPointerError extends JSONParserError {\n  code \u003d \"EMISSINGPOINTER\" as JSONParserErrorType;\n  name \u003d \"MissingPointerError\";\n  public targetToken: any;\n  public targetRef: string;\n  public targetFound: string;\n  public parentPath: string;\n  constructor(token: any, path: any, targetRef: any, targetFound: any, parentPath: any) {\n    super(`Missing $ref pointer \"${getHash(path)}\". Token \"${token}\" does not exist.`, stripHash(path));\n\n    this.targetToken \u003d token;\n    this.targetRef \u003d targetRef;\n    this.targetFound \u003d targetFound;\n    this.parentPath \u003d parentPath;\n  }\n}\n\nexport class TimeoutError extends JSONParserError {\n  code \u003d \"ETIMEOUT\" as JSONParserErrorType;\n  name \u003d \"TimeoutError\";\n  constructor(timeout: number) {\n    super(`Dereferencing timeout reached: ${timeout}ms`);\n  }\n}\n\nexport class InvalidPointerError extends JSONParserError {\n  code \u003d \"EUNMATCHEDRESOLVER\" as JSONParserErrorType;\n  name \u003d \"InvalidPointerError\";\n  constructor(pointer: string, path: string) {\n    super(`Invalid $ref pointer \"${pointer}\". Pointers must begin with \"#/\"`, stripHash(path));\n  }\n}\n\nexport function isHandledError(err: any): err is JSONParserError {\n  return err instanceof JSONParserError || err instanceof JSONParserErrorGroup;\n}\n\nexport function normalizeError(err: any) {\n  if (err.path \u003d\u003d\u003d null) {\n    err.path \u003d [];\n  }\n\n  return err;\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/util/is-windows.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nconst isWindowsConst \u003d /^win/.test(globalThis.process ? globalThis.process.platform : \"\");\nexport const isWindows \u003d () \u003d\u003e isWindowsConst;\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/util/maybe.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport next from \"./next.js\";\n\ntype MaybeParams\u003cT\u003e \u003d (err: Error | any | null, result?: T) \u003d\u003e void;\nexport default function maybe\u003cT\u003e(cb: MaybeParams\u003cT\u003e | undefined, promise: Promise\u003cT\u003e): Promise\u003cT\u003e | void {\n  if (cb) {\n    promise.then(\n      function (result) {\n        next(function () {\n          cb(null, result);\n        });\n      },\n      function (err) {\n        next(function () {\n          cb(err);\n        });\n      },\n    );\n    return undefined;\n  } else {\n    return promise;\n  }\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/util/next.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nfunction makeNext() {\n  if (typeof process \u003d\u003d\u003d \"object\" \u0026\u0026 typeof process.nextTick \u003d\u003d\u003d \"function\") {\n    return process.nextTick;\n  } else if (typeof setImmediate \u003d\u003d\u003d \"function\") {\n    return setImmediate;\n  } else {\n    return function next(f: () \u003d\u003e void) {\n      setTimeout(f, 0);\n    };\n  }\n}\n\nexport default makeNext();\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/util/plugins.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport type { FileInfo, JSONSchema } from \"../types/index.js\";\nimport type { ParserOptions } from \"../options.js\";\nimport type { ResolverOptions } from \"../types/index.js\";\nimport type $Refs from \"../refs.js\";\nimport type { Plugin } from \"../types/index.js\";\n\n/**\n * Returns the given plugins as an array, rather than an object map.\n * All other methods in this module expect an array of plugins rather than an object map.\n *\n * @returns\n */\nexport function all\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  plugins: O[\"resolve\"],\n): Plugin[] {\n  return (Object.keys(plugins || {}) as (keyof ResolverOptions\u003cS\u003e)[])\n    .filter((key) \u003d\u003e {\n      return typeof plugins![key] \u003d\u003d\u003d \"object\";\n    })\n    .map((key) \u003d\u003e {\n      (plugins![key] as ResolverOptions\u003cS\u003e)!.name \u003d key;\n      return plugins![key] as Plugin;\n    });\n}\n\n/**\n * Filters the given plugins, returning only the ones return `true` for the given method.\n */\nexport function filter(plugins: Plugin[], method: any, file: any) {\n  return plugins.filter((plugin: Plugin) \u003d\u003e {\n    return !!getResult(plugin, method, file);\n  });\n}\n\n/**\n * Sorts the given plugins, in place, by their `order` property.\n */\nexport function sort(plugins: Plugin[]) {\n  for (const plugin of plugins) {\n    plugin.order \u003d plugin.order || Number.MAX_SAFE_INTEGER;\n  }\n\n  return plugins.sort((a: any, b: any) \u003d\u003e {\n    return a.order - b.order;\n  });\n}\n\nexport interface PluginResult\u003cS extends object \u003d JSONSchema\u003e {\n  plugin: Plugin;\n  result?: string | Buffer | S;\n  error?: any;\n}\n\n/**\n * Runs the specified method of the given plugins, in order, until one of them returns a successful result.\n * Each method can return a synchronous value, a Promise, or call an error-first callback.\n * If the promise resolves successfully, or the callback is called without an error, then the result\n * is immediately returned and no further plugins are called.\n * If the promise rejects, or the callback is called with an error, then the next plugin is called.\n * If ALL plugins fail, then the last error is thrown.\n */\nexport async function run\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  plugins: Plugin[],\n  method: keyof Plugin | keyof ResolverOptions\u003cS\u003e,\n  file: FileInfo,\n  $refs: $Refs\u003cS, O\u003e,\n) {\n  let plugin: Plugin;\n  let lastError: PluginResult\u003cS\u003e;\n  let index \u003d 0;\n\n  return new Promise\u003cPluginResult\u003cS\u003e\u003e((resolve, reject) \u003d\u003e {\n    runNextPlugin();\n\n    function runNextPlugin() {\n      plugin \u003d plugins[index++];\n      if (!plugin) {\n        // There are no more functions, so re-throw the last error\n        return reject(lastError);\n      }\n\n      try {\n        // console.log(\u0027  %s\u0027, plugin.name);\n        const result \u003d getResult(plugin, method, file, callback, $refs);\n        if (result \u0026\u0026 typeof result.then \u003d\u003d\u003d \"function\") {\n          // A promise was returned\n          result.then(onSuccess, onError);\n        } else if (result !\u003d\u003d undefined) {\n          // A synchronous result was returned\n          onSuccess(result);\n        } else if (index \u003d\u003d\u003d plugins.length) {\n          throw new Error(\"No promise has been returned or callback has been called.\");\n        }\n      } catch (e) {\n        onError(e);\n      }\n    }\n\n    function callback(err: PluginResult\u003cS\u003e[\"error\"], result: PluginResult\u003cS\u003e[\"result\"]) {\n      if (err) {\n        onError(err);\n      } else {\n        onSuccess(result);\n      }\n    }\n\n    function onSuccess(result: PluginResult\u003cS\u003e[\"result\"]) {\n      // console.log(\u0027    success\u0027);\n      resolve({\n        plugin,\n        result,\n      });\n    }\n\n    function onError(error: PluginResult\u003cS\u003e[\"error\"]) {\n      // console.log(\u0027    %s\u0027, err.message || err);\n      lastError \u003d {\n        plugin,\n        error,\n      };\n      runNextPlugin();\n    }\n  });\n}\n\n/**\n * Returns the value of the given property.\n * If the property is a function, then the result of the function is returned.\n * If the value is a RegExp, then it will be tested against the file URL.\n * If the value is an array, then it will be compared against the file extension.\n */\nfunction getResult\u003cS extends object \u003d JSONSchema, O extends ParserOptions\u003cS\u003e \u003d ParserOptions\u003cS\u003e\u003e(\n  obj: Plugin,\n  prop: keyof Plugin | keyof ResolverOptions\u003cS\u003e,\n  file: FileInfo,\n  callback?: (err?: Error, result?: any) \u003d\u003e void,\n  $refs?: $Refs\u003cS, O\u003e,\n) {\n  const value \u003d obj[prop as keyof typeof obj] as unknown;\n\n  if (typeof value \u003d\u003d\u003d \"function\") {\n    return value.apply(obj, [file, callback, $refs]);\n  }\n\n  if (!callback) {\n    // The synchronous plugin functions (canParse and canRead)\n    // allow a \"shorthand\" syntax, where the user can match\n    // files by RegExp or by file extension.\n    if (value instanceof RegExp) {\n      return value.test(file.url);\n    } else if (typeof value \u003d\u003d\u003d \"string\") {\n      return value \u003d\u003d\u003d file.extension;\n    } else if (Array.isArray(value)) {\n      return value.indexOf(file.extension) !\u003d\u003d -1;\n    }\n  }\n\n  return value;\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: lib/util/url.ts\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nimport convertPathToPosix from \"./convert-path-to-posix\";\nimport path, { win32 } from \"path\";\n\nconst forwardSlashPattern \u003d /\\//g;\nconst protocolPattern \u003d /^(\\w{2,}):\\/\\//i;\nconst jsonPointerSlash \u003d /~1/g;\nconst jsonPointerTilde \u003d /~0/g;\n\nimport { join } from \"path\";\nimport { isWindows } from \"./is-windows\";\n\n// RegExp patterns to URL-encode special characters in local filesystem paths\nconst urlEncodePatterns \u003d [\n  [/\\?/g, \"%3F\"],\n  [/#/g, \"%23\"],\n] as [RegExp, string][];\n\n// RegExp patterns to URL-decode special characters for local filesystem paths\nconst urlDecodePatterns \u003d [/%23/g, \"#\", /%24/g, \"$\", /%26/g, \"\u0026\", /%2C/g, \",\", /%40/g, \"@\"];\n\nexport const parse \u003d (u: string | URL) \u003d\u003e new URL(u);\n\n/**\n * Returns resolved target URL relative to a base URL in a manner similar to that of a Web browser resolving an anchor tag HREF.\n *\n * @returns\n */\nexport function resolve(from: string, to: string) {\n  // we use a non-existent URL to check if its a relative URL\n  const fromUrl \u003d new URL(convertPathToPosix(from), \"https://aaa.nonexistanturl.com\");\n  const resolvedUrl \u003d new URL(convertPathToPosix(to), fromUrl);\n  const endSpaces \u003d to.match(/(\\s*)$/)?.[1] || \"\";\n  if (resolvedUrl.hostname \u003d\u003d\u003d \"aaa.nonexistanturl.com\") {\n    // `from` is a relative URL.\n    const { pathname, search, hash } \u003d resolvedUrl;\n    return pathname + search + hash + endSpaces;\n  }\n  return resolvedUrl.toString() + endSpaces;\n}\n\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns\n */\nexport function cwd() {\n  if (typeof window !\u003d\u003d \"undefined\") {\n    return location.href;\n  }\n\n  const path \u003d process.cwd();\n\n  const lastChar \u003d path.slice(-1);\n  if (lastChar \u003d\u003d\u003d \"/\" || lastChar \u003d\u003d\u003d \"\\\\\") {\n    return path;\n  } else {\n    return path + \"/\";\n  }\n}\n\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param path\n * @returns\n */\nexport function getProtocol(path: string | undefined) {\n  const match \u003d protocolPattern.exec(path || \"\");\n  if (match) {\n    return match[1].toLowerCase();\n  }\n  return undefined;\n}\n\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param path\n * @returns\n */\nexport function getExtension(path: any) {\n  const lastDot \u003d path.lastIndexOf(\".\");\n  if (lastDot \u003e\u003d 0) {\n    return stripQuery(path.substr(lastDot).toLowerCase());\n  }\n  return \"\";\n}\n\n/**\n * Removes the query, if any, from the given path.\n *\n * @param path\n * @returns\n */\nexport function stripQuery(path: any) {\n  const queryIndex \u003d path.indexOf(\"?\");\n  if (queryIndex \u003e\u003d 0) {\n    path \u003d path.substr(0, queryIndex);\n  }\n  return path;\n}\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param path\n * @returns\n */\nexport function getHash(path: undefined | string) {\n  if (!path) {\n    return \"#\";\n  }\n  const hashIndex \u003d path.indexOf(\"#\");\n  if (hashIndex \u003e\u003d 0) {\n    return path.substring(hashIndex);\n  }\n  return \"#\";\n}\n\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param path\n * @returns\n */\nexport function stripHash(path?: string | undefined) {\n  if (!path) {\n    return \"\";\n  }\n  const hashIndex \u003d path.indexOf(\"#\");\n  if (hashIndex \u003e\u003d 0) {\n    path \u003d path.substring(0, hashIndex);\n  }\n  return path;\n}\n\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param path\n * @returns\n */\nexport function isHttp(path: string) {\n  const protocol \u003d getProtocol(path);\n  if (protocol \u003d\u003d\u003d \"http\" || protocol \u003d\u003d\u003d \"https\") {\n    return true;\n  } else if (protocol \u003d\u003d\u003d undefined) {\n    // There is no protocol.  If we\u0027re running in a browser, then assume it\u0027s HTTP.\n    return typeof window !\u003d\u003d \"undefined\";\n  } else {\n    // It\u0027s some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n    return false;\n  }\n}\n\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param path\n * @returns\n */\nexport function isFileSystemPath(path: string | undefined) {\n  // @ts-ignore\n  if (typeof window !\u003d\u003d \"undefined\" || (typeof process !\u003d\u003d \"undefined\" \u0026\u0026 process.browser)) {\n    // We\u0027re running in a browser, so assume that all paths are URLs.\n    // This way, even relative paths will be treated as URLs rather than as filesystem paths\n    return false;\n  }\n\n  const protocol \u003d getProtocol(path);\n  return protocol \u003d\u003d\u003d undefined || protocol \u003d\u003d\u003d \"file\";\n}\n\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    \u003c\"!@#$%^\u0026*+\u003d?\u0027\u003e.json              \u003d\u003d\u003e   %3C%22!@%23$%25%5E\u0026*+\u003d%3F\\\u0027%3E.json\n *    C:\\\\My Documents\\\\File (1).json   \u003d\u003d\u003e   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      \u003d\u003d\u003e   file://Project%20%2342/file.json\n *\n * @param path\n * @returns\n */\nexport function fromFileSystemPath(path: string) {\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows()) {\n    const projectDir \u003d cwd();\n    const upperPath \u003d path.toUpperCase();\n    const projectDirPosixPath \u003d convertPathToPosix(projectDir);\n    const posixUpper \u003d projectDirPosixPath.toUpperCase();\n    const hasProjectDir \u003d upperPath.includes(posixUpper);\n    const hasProjectUri \u003d upperPath.includes(posixUpper);\n    const isAbsolutePath \u003d\n      win32?.isAbsolute(path) ||\n      path.startsWith(\"http://\") ||\n      path.startsWith(\"https://\") ||\n      path.startsWith(\"file://\");\n\n    if (!(hasProjectDir || hasProjectUri || isAbsolutePath) \u0026\u0026 !projectDir.startsWith(\"http\")) {\n      path \u003d join(projectDir, path);\n    }\n    path \u003d convertPathToPosix(path);\n  }\n\n  // Step 2: `encodeURI` will take care of MOST characters\n  path \u003d encodeURI(path);\n\n  // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (const pattern of urlEncodePatterns) {\n    path \u003d path.replace(pattern[0], pattern[1]);\n  }\n\n  return path;\n}\n\n/**\n * Converts a URL to a local filesystem path.\n */\nexport function toFileSystemPath(path: string | undefined, keepFileProtocol?: boolean): string {\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  path \u003d decodeURI(path!);\n\n  // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i \u003d 0; i \u003c urlDecodePatterns.length; i +\u003d 2) {\n    path \u003d path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1] as string);\n  }\n\n  // Step 3: If it\u0027s a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n  let isFileUrl \u003d path.substr(0, 7).toLowerCase() \u003d\u003d\u003d \"file://\";\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path \u003d path[7] \u003d\u003d\u003d \"/\" ? path.substr(8) : path.substr(7);\n\n    // insert a colon (\":\") after the drive letter on Windows\n    if (isWindows() \u0026\u0026 path[1] \u003d\u003d\u003d \"/\") {\n      path \u003d path[0] + \":\" + path.substr(1);\n    }\n\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path \u003d \"file:///\" + path;\n    } else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl \u003d false;\n      path \u003d isWindows() ? path : \"/\" + path;\n    }\n  }\n\n  // Step 4: Normalize Windows paths (unless it\u0027s a \"file://\" URL)\n  if (isWindows() \u0026\u0026 !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path \u003d path.replace(forwardSlashPattern, \"\\\\\");\n\n    // Capitalize the drive letter\n    if (path.substr(1, 2) \u003d\u003d\u003d \":\\\\\") {\n      path \u003d path[0].toUpperCase() + path.substr(1);\n    }\n  }\n\n  return path;\n}\n\n/**\n * Converts a $ref pointer to a valid JSON Path.\n *\n * @param pointer\n * @returns\n */\nexport function safePointerToPath(pointer: any) {\n  if (pointer.length \u003c\u003d 1 || pointer[0] !\u003d\u003d \"#\" || pointer[1] !\u003d\u003d \"/\") {\n    return [];\n  }\n\n  return pointer\n    .slice(2)\n    .split(\"/\")\n    .map((value: any) \u003d\u003e {\n      return decodeURIComponent(value).replace(jsonPointerSlash, \"/\").replace(jsonPointerTilde, \"~\");\n    });\n}\n\nexport function relative(from: string, to: string) {\n  if (!isFileSystemPath(from) || !isFileSystemPath(to)) {\n    return resolve(from, to);\n  }\n\n  const fromDir \u003d path.dirname(stripHash(from));\n  const toPath \u003d stripHash(to);\n\n  const result \u003d path.relative(fromDir, toPath);\n  return result + getHash(to);\n}\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: .github/FUNDING.yml\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\ngithub: philsturgeon\n\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\nFile: .github/workflows/CI-CD.yaml\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n# GitHub Actions workflow\n# https://help.github.com/en/actions/automating-your-workflow-with-github-actions\n# https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions\n# https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions\n# https://www.npmjs.com/package/@amanda-mitchell/semantic-release-npm-multiple\n\nname: CI-CD\n\non:\n  push:\n    branches:\n      - main\n  pull_request:\n\njobs:\n  node_tests:\n    name: Node ${{ matrix.node }} on ${{ matrix.os }}\n    runs-on: ${{ matrix.os }}\n    timeout-minutes: 10\n    strategy:\n      fail-fast: true\n      matrix:\n        os:\n          - ubuntu-latest\n          - macos-latest\n          - windows-latest\n        node:\n          - 20\n          - lts/*\n          - current\n\n    steps:\n      - name: Checkout source\n        uses: actions/checkout@v4\n\n      - name: Install Node ${{ matrix.node }}\n        uses: actions/setup-node@v4\n        with:\n          node-version: ${{ matrix.node }}\n\n      - name: Install dependencies\n        run: yarn install --frozen-lockfile\n\n      - name: Run linter\n        run: yarn lint\n\n      - name: Run Node tests\n        run: yarn test:node\n\n      - name: Send code coverage results to Coveralls\n        uses: coverallsapp/github-action@v2\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          parallel: true\n\n  browser_tests:\n    name: Browser Tests\n    runs-on: ${{ matrix.os }}\n    timeout-minutes: 15\n    strategy:\n      fail-fast: true\n      matrix:\n        os:\n          - ubuntu-latest # Chrome, Firefox\n          - windows-latest # Internet Explorer\n\n    steps:\n      - name: Checkout source\n        uses: actions/checkout@v4\n\n      - name: Install Node\n        uses: actions/setup-node@v4\n        with:\n          node-version: lts/*\n\n      - name: Install dependencies\n        run: yarn install --frozen-lockfile\n\n      - name: Run tests\n        run: yarn test:browser\n\n      - name: Send code coverage results to Coveralls\n        uses: coverallsapp/github-action@v2\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          parallel: true\n\n  coverage:\n    name: Code Coverage\n    runs-on: ubuntu-latest\n    timeout-minutes: 5\n    needs:\n      - node_tests\n      - browser_tests\n    steps:\n      - name: Let Coveralls know that all tests have finished\n        uses: coverallsapp/github-action@v2\n        with:\n          github-token: ${{ secrets.GITHUB_TOKEN }}\n          parallel-finished: true\n\n  release:\n    name: Release\n    if: github.ref \u003d\u003d \u0027refs/heads/main\u0027\n    runs-on: ubuntu-latest\n    timeout-minutes: 10\n    needs:\n      - node_tests\n      - browser_tests\n    steps:\n      - uses: actions/checkout@v4\n      - uses: actions/setup-node@v4\n        with:\n          node-version: lts/*\n\n      - name: Install dependencies\n        run: yarn install --frozen-lockfile\n\n      - name: Prepare Unscoped Package\n        run: yarn build\n\n      - name: Publish to NPM\n        run: npx semantic-release\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}\n```\n\nI want to port this to run in the frontend easily without having to deal with webpack and shims for Node features.\nStart by sharing very detailed working out.\nThen review the key algo and the current Node.js dependent parts.\nReport on a possible conversion path with minimal, surgical like changes. Also provide a minimal reimplementation that has few lines of code and works in the browser directly (aim for up to ~300 lines).",
      "role": "user",
      "tokenCount": 51215
    }, {
      "text": "Okay, let\u0027s break down porting `json-schema-ref-parser` to the browser with minimal changes and then consider a more streamlined, browser-native implementation.\n\n**1. Detailed Working Out \u0026 Analysis**\n\nThe goal is to make this library work directly in a browser environment *without* requiring bundlers like Webpack, Rollup, Parcel, or Browserify, and without relying on Node.js-specific polyfills. This means avoiding or replacing any code that depends on Node.js built-in modules.\n\nHere\u0027s a step-by-step analysis of the provided code, identifying Node.js dependencies and outlining the conversion strategy:\n\n*   **File System Access (`fs` module):**  This is the biggest hurdle.  The `lib/resolvers/file.ts` file uses `fs.promises.readFile` to load local files.  Browsers *cannot* access the local file system directly for security reasons.  We\u0027ll need a completely different approach for handling \"file\" references in the browser.\n\n*   **HTTP Requests (`node-fetch` or similar):** The `lib/resolvers/http.ts` uses `fetch` to make HTTP requests. While `fetch` is a web standard, the provided code assumes Node.js behavior.  We need to ensure it uses the browser\u0027s built-in `fetch` correctly, handling potential differences (e.g., CORS). The code already does a `typeof window !\u003d\u003d \"undefined\"` check, which is a good start.\n\n*   **Path Manipulation (`path` module):**  The code uses `path.join`, `path.dirname`, `path.relative`, `path.win32.sep`, `path.posix.sep`, and `path.win32.isAbsolute`.  We\u0027ll need to replace these with URL-based manipulations or, if absolutely necessary for edge cases, a very small, focused path manipulation library (or custom functions).  The good news is that most of the path manipulation is already URL-centric, thanks to the use of the `URL` object.\n\n*   **Buffer (`Buffer` class):** The code uses `Buffer.isBuffer`, `Buffer.from`, and `Buffer.alloc`. Browsers have `Uint8Array` and other typed arrays, which are the standard way to handle binary data. We\u0027ll need to replace `Buffer` usage with these.\n\n*   **Process (`process` object):** The code uses `process.cwd()` to get the current working directory and `process.platform` and `process.nextTick`. We can replace `process.cwd()` with a URL-based approach (using the current page\u0027s URL as the base). `process.platform` is used to detect Windows for path handling; we can use `navigator.userAgent` as a (less reliable) alternative or, better, focus on URL-based path handling.  `process.nextTick` is used for asynchronous callbacks. We can replace it with `setTimeout(..., 0)` or `queueMicrotask`.\n\n*   **YAML Parsing (`js-yaml`):** The `lib/parsers/yaml.ts` file uses the `js-yaml` library.  This library *does* have a browser-compatible build. We can use the browser version directly, ideally without needing a bundler.  We could load it via a `\u003cscript\u003e` tag or use a CDN.\n\n*   **Error Handling (`@jsdevtools/ono`):**  This library is used for creating rich, structured errors.  While not strictly Node.js-dependent, it adds to the bundle size.  We can likely replace it with standard `Error` objects or custom error classes for a minimal implementation.\n\n*   **`globalThis.fetch`:** The README mentions polyfilling `fetch` for older Node.js versions. In the browser, we *don\u0027t* want to do this; we want to use the built-in `fetch`.\n\n*   **`convert-path-to-posix` function:** This is related to file system.\n\n*   **`is-windows` function:** This is related to file system.\n\n* **`maybe` function:** This is used to handle callbacks vs. Promises. We can simplify this.\n\n* **`next` function:** This is used for asynchronous callbacks. We can replace it with `setTimeout(..., 0)` or `queueMicrotask`.\n\n* **`plugins` function:** This is used for managing resolvers and parsers. We can simplify this.\n\n* **`url` function:** This has many helper functions, some of which are Node.js dependent. We can simplify this.\n\n**2. Key Algorithms**\n\nThe core algorithms of the library are:\n\n1.  **Parsing:** Reading the initial schema (and any referenced schemas) and converting it into a JavaScript object. This involves handling different file types (JSON, YAML, text, binary).\n\n2.  **Resolving References:**  Finding the values pointed to by `$ref` properties.  This involves:\n    *   Handling relative and absolute URLs.\n    *   Handling file system paths (which we\u0027ll need to adapt for the browser).\n    *   Downloading external resources via HTTP.\n    *   Dealing with circular references.\n\n3.  **Bundling:** Combining multiple schema files into a single schema with only internal references.\n\n4.  **Dereferencing:** Replacing all `$ref` pointers with their actual values, creating a plain JavaScript object.\n\n**3. Conversion Path (Minimal, Surgical Changes)**\n\nThis approach focuses on modifying the existing code as little as possible to achieve browser compatibility.\n\n1.  **Resolver Refactoring:**\n    *   **`lib/resolvers/file.ts`:**  Completely remove this file and its associated logic.  In the browser, we\u0027ll assume that all references are URLs (either relative to the main schema or absolute).  We won\u0027t support \"file://\" URLs or local file paths.\n    *   **`lib/resolvers/http.ts`:**\n        *   Remove the `u.protocol` check that defaults to the current page\u0027s protocol.  Instead, *require* that all URLs be fully-qualified (start with `http://` or `https://`). This simplifies the logic and avoids potential security issues.\n        *   Ensure that the `fetch` calls are using browser-compatible options (e.g., `credentials: \u0027same-origin\u0027` is generally appropriate).\n        *   Remove the Node.js-specific error handling (using `ono`) and replace it with standard `Error` objects or a minimal custom error class.\n\n2.  **Path Handling:**\n    *   Replace all uses of the `path` module with URL manipulation using the `URL` object.  For example, instead of `path.join`, use `new URL(ref, baseUrl)`.\n    *   Remove `convert-path-to-posix` and `is-windows`.\n\n3.  **Buffer Replacement:**\n    *   Replace all uses of `Buffer` with `Uint8Array`.  For example, instead of `Buffer.from(data)`, use `new Uint8Array(data)`. Instead of `Buffer.isBuffer(data)`, use `data instanceof Uint8Array`.\n    *   When converting strings to `Uint8Array`, use the `TextEncoder` API: `new TextEncoder().encode(stringData)`.\n    *   When converting `Uint8Array` to strings, use the `TextDecoder` API: `new TextDecoder().decode(uint8ArrayData)`.\n\n4.  **`process` Replacement:**\n    *   Replace `process.cwd()` with a URL-based approach.  The initial schema\u0027s URL will serve as the base URL for resolving relative references.\n    *   Remove `process.platform`.\n    *   Replace `process.nextTick` with `setTimeout(..., 0)` or, better, `queueMicrotask(...)`.\n\n5.  **`js-yaml`:**  Use the browser-compatible build of `js-yaml`.  You can likely load it directly from a CDN in your HTML:\n\n    ```html\n    \u003cscript src\u003d\"https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js\"\u003e\u003c/script\u003e\n    ```\n\n6.  **`@jsdevtools/ono`:** Remove this dependency. Use standard `Error` objects or create simple custom error classes if you need specific error types.\n\n7.  **`globalThis.fetch`:** Remove any code that attempts to polyfill `fetch`.\n\n8. **`normalizeArgs`:** Simplify by accepting only named parameters.\n\n**4. Minimal Reimplementation (Browser-Native, ~300 Lines)**\n\nThis is a *highly simplified* version, focusing on the core dereferencing functionality and making several simplifying assumptions. It does *not* handle all the features of the original library (e.g., bundling, custom resolvers/parsers). It\u0027s intended to demonstrate a browser-native approach.\n\n```javascript\nclass RefParser {\n  constructor() {\n    this.cache \u003d new Map();\n  }\n\n  async dereference(schemaOrURL, baseUrl \u003d null) {\n    const schema \u003d typeof schemaOrURL \u003d\u003d\u003d \u0027string\u0027 ? await this.fetchSchema(schemaOrURL) : schemaOrURL;\n    baseUrl \u003d baseUrl || (typeof schemaOrURL \u003d\u003d\u003d \u0027string\u0027 ? schemaOrURL : window.location.href);\n\n    return this.resolveRefs(schema, baseUrl);\n  }\n\n  async fetchSchema(url) {\n    if (this.cache.has(url)) {\n      return this.cache.get(url);\n    }\n\n    const response \u003d await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${url}: ${response.status}`);\n    }\n    const text \u003d await response.text();\n    const schema \u003d this.parseContent(text, url); // Determine JSON or YAML\n    this.cache.set(url, schema);\n    return schema;\n  }\n\n  parseContent(text, url) {\n      const ext \u003d url.split(\"?\")[0].split(\"#\")[0].split(\".\").pop().toLowerCase();\n    if (ext \u003d\u003d\u003d \u0027json\u0027) {\n        return JSON.parse(text);\n    } else if (ext \u003d\u003d\u003d \u0027yaml\u0027 || ext \u003d\u003d\u003d \u0027yml\u0027) {\n        return jsyaml.load(text); // Assuming jsyaml is loaded globally\n    }\n    throw new Error(`Unsupported file type: ${url}`);\n  }\n\n  async resolveRefs(schema, baseUrl) {\n    if (typeof schema !\u003d\u003d \u0027object\u0027 || schema \u003d\u003d\u003d null) {\n      return schema;\n    }\n\n    if (Array.isArray(schema)) {\n      const resolvedArray \u003d [];\n      for (const item of schema) {\n        resolvedArray.push(await this.resolveRefs(item, baseUrl));\n      }\n      return resolvedArray;\n    }\n\n    if (schema.$ref \u0026\u0026 typeof schema.$ref \u003d\u003d\u003d \u0027string\u0027) {\n      const [refUrl, refPointer] \u003d schema.$ref.split(\u0027#\u0027);\n      const fullRefUrl \u003d refUrl ? new URL(refUrl, baseUrl).href : baseUrl;\n      let resolvedSchema \u003d await this.fetchSchema(fullRefUrl);\n\n      if (refPointer) {\n          resolvedSchema \u003d this.resolvePointer(resolvedSchema, refPointer);\n      }\n      // Handle remaining properties if $ref is not alone\n      if(Object.keys(schema).length \u003e 1) {\n            const cloned \u003d { ...resolvedSchema }\n            for(const key in schema) {\n                if(key !\u003d\u003d \u0027$ref\u0027) {\n                    cloned[key] \u003d schema[key];\n                }\n            }\n            return this.resolveRefs(cloned, baseUrl);\n      }\n\n\n      return this.resolveRefs(resolvedSchema, fullRefUrl); // Recursively resolve refs in the fetched schema\n    }\n\n    const resolvedObject \u003d {};\n    for (const key in schema) {\n      resolvedObject[key] \u003d await this.resolveRefs(schema[key], baseUrl);\n    }\n    return resolvedObject;\n  }\n\n    resolvePointer(schema, pointer) {\n        if (!pointer) {\n            return schema;\n        }\n        const parts \u003d pointer.substring(1).split(\u0027/\u0027).map(part \u003d\u003e\n            part.replace(/~1/g, \u0027/\u0027).replace(/~0/g, \u0027~\u0027)\n        );\n        let current \u003d schema;\n        for (const part of parts) {\n            if (current \u0026\u0026 typeof current \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 part in current) {\n                current \u003d current[part];\n            } else {\n                throw new Error(`Invalid JSON pointer: ${pointer}`);\n            }\n        }\n        return current;\n    }\n}\n\n// Example usage (assuming js-yaml is loaded via a \u003cscript\u003e tag):\n// const parser \u003d new RefParser();\n// parser.dereference(\u0027my-schema.json\u0027)\n//   .then(schema \u003d\u003e console.log(schema))\n//   .catch(error \u003d\u003e console.error(error));\n\n// In an HTML file:\n// \u003cscript src\u003d\"https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js\"\u003e\u003c/script\u003e\n// \u003cscript src\u003d\"ref-parser.js\"\u003e\u003c/script\u003e \u003c--- Your RefParser class\n// \u003cscript\u003e\n//   const parser \u003d new RefParser();\n//   parser.dereference(\u0027schema.json\u0027)  // Assumes schema.json is in the same directory\n//     .then(schema \u003d\u003e {\n//       console.log(\u0027Dereferenced Schema:\u0027, schema);\n//     })\n//     .catch(err \u003d\u003e {\n//       console.error(\u0027Error:\u0027, err);\n//     });\n// \u003c/script\u003e\n```\n\nKey improvements and explanations of the minimal implementation:\n\n*   **`fetchSchema`:**  Handles fetching and caching of schemas to avoid redundant network requests.  It uses the browser\u0027s built-in `fetch` API.  It also handles basic error checking (response.ok).\n*   **`parseContent`:** This function handles determining if the content is json or yaml, and parses it accordingly.\n*   **`resolveRefs`:**  This is the core recursive function.\n    *   It handles base cases (non-objects, arrays).\n    *   It checks for `$ref` properties.\n    *   It constructs the full URL of the referenced schema using `new URL(refUrl, baseUrl)`.  This handles relative and absolute URLs correctly.\n    *   It calls `fetchSchema` to load the referenced schema (which might be cached).\n    *   It handles JSON Pointers (the part after the `#`) using `resolvePointer`.\n    *   It recursively calls `resolveRefs` on the fetched schema and on the properties of the current schema.\n*   **`resolvePointer`:** This function resolves a json pointer.\n*  **No `fs` module:** The code does not use the `fs` module at all.\n*   **No `path` module:**  The code uses the `URL` object for all URL manipulation.\n*   **No `Buffer`:** The code uses `fetch` which returns string, and then uses `JSON.parse` to get the object.\n*   **No `process`:** The code does not use the `process` object.\n*  **Simplified error handling:** Uses standard `Error` objects.\n*  **Uses `async/await`:** Makes the asynchronous code easier to read and write.\n*   **Assumes `jsyaml` is available:**  This is a simplification.  In a real-world scenario, you might want to bundle `js-yaml` or use a module loader.\n* **Handles Properties alongside $ref:** Handles the case where there are properties alongside `$ref`.\n\nThis minimal implementation provides a good starting point.  You could expand it to handle more edge cases, add more robust error handling, and potentially implement a basic form of bundling. The most important takeaway is that by relying on web standards (`fetch`, `URL`, `TextEncoder`, `TextDecoder`), you can create a much smaller and simpler browser-compatible version of the library.\n",
      "role": "model",
      "safetyRatings": [{
        "category": "HARM_CATEGORY_DANGEROUS_CONTENT",
        "probability": "LOW"
      }],
      "finishReason": "STOP",
      "tokenCount": 3534
    }, {
      "text": "Start by sharing detailed working out.\nWhat is ono? Why is there a YAML dependency for a JSON dereferencing utility? YAML support must be optional, right? I never saw a YAML JSON schema before (unless Swagger OpenAPI had some).\nReview your minimal reimplementation.\nI just want a JSON Schema dereferencing utility that works in the browser. It should have a middleware function that I can easily customise with a custom function that alters requests and maybe responses, so I can easily make it work with different CORS situations, including using a specific proxy. It should be one single combined snippet. After reviewing, provide a full minimal reimplementation with a custom middleware example. It SHOULD support relative paths.",
      "role": "user",
      "tokenCount": 143
    }, {
      "text": "Okay, let\u0027s refine the approach, address your specific requirements (middleware, focus on JSON, optional YAML, relative paths), and provide a more complete and robust minimal implementation.\n\n**1. Detailed Working Out \u0026 Analysis (Revised)**\n\n*   **`@jsdevtools/ono`:** Ono is a library for creating more informative error objects. It adds context (like file paths, line numbers) to errors, making debugging easier. For our minimal implementation, we\u0027ll replace it with standard `Error` objects or a very simple custom error class. This reduces dependencies and keeps the code small.  We *won\u0027t* try to replicate all of Ono\u0027s features.\n\n*   **YAML Dependency (`js-yaml`):** You\u0027re absolutely right; YAML support should be optional.  The original `json-schema-ref-parser` supports both JSON and YAML schemas, which is why it includes `js-yaml`.  For a *JSON-only* dereferencer, we can completely remove this dependency.  If we want to add YAML support back in *optionally*, we can do so in a way that doesn\u0027t force users to include `js-yaml` if they don\u0027t need it.  We\u0027ll address this in the implementation.\n\n*   **Swagger/OpenAPI and YAML:** You\u0027re also correct that OpenAPI (formerly Swagger) specifications are often written in YAML. This is a primary use case for supporting YAML in a JSON Schema parser, as OpenAPI schemas frequently use `$ref` to reference other schema components, which can be in separate files. Since you want to focus on JSON Schema, we\u0027ll make YAML support optional.\n\n*   **Middleware:**  This is a crucial requirement. We need a way for the user to intercept and modify both requests (e.g., add headers, change URLs) and responses (e.g., handle CORS issues, pre-process data).  We\u0027ll design the `fetchSchema` function to accept a middleware function as an argument.\n\n*   **Relative Paths:**  The minimal implementation *already* supports relative paths, thanks to the use of `new URL(refUrl, baseUrl)`. This is the correct way to handle relative URLs in the browser. We\u0027ll keep this approach.\n\n*   **Single Snippet:**  The goal is to have a single, self-contained JavaScript code block that can be copied and pasted into a browser environment without needing any build tools or external dependencies (except *optionally* `js-yaml` if YAML support is desired).\n\n**2. Minimal Reimplementation (Revised)**\n\n```javascript\nclass JSONSchemaRefParser {\n  constructor() {\n    this.cache \u003d new Map();\n  }\n\n  async dereference(schemaOrURL, options \u003d {}) {\n    const { middleware \u003d this.defaultMiddleware, yaml \u003d false } \u003d options;\n    let baseUrl \u003d options.baseUrl || null;\n\n    const schema \u003d typeof schemaOrURL \u003d\u003d\u003d \u0027string\u0027 ?\n      await this.fetchSchema(schemaOrURL, middleware, yaml) :\n      schemaOrURL;\n\n    baseUrl \u003d baseUrl || (typeof schemaOrURL \u003d\u003d\u003d \u0027string\u0027 ? schemaOrURL : window.location.href);\n\n    return this.resolveRefs(schema, baseUrl, new Set(), middleware);\n  }\n\n  async fetchSchema(url, middleware, yaml \u003d false) {\n    if (this.cache.has(url)) {\n      return this.cache.get(url);\n    }\n\n    let [request, callback] \u003d middleware({ url, method: \u0027GET\u0027 }, null);\n    if (!request) {\n      request \u003d { url, method: \u0027GET\u0027 };\n    }\n\n    const response \u003d await fetch(request.url, request);\n\n    let [modifiedResponse, parsed] \u003d middleware(request, response);\n    if (!modifiedResponse) {\n      modifiedResponse \u003d response;\n    }\n\n    if (!modifiedResponse.ok) {\n      throw new Error(`Failed to fetch ${request.url}: ${modifiedResponse.status}`);\n    }\n\n    const text \u003d await modifiedResponse.text();\n\n    if (!parsed) {\n        parsed \u003d this.parseContent(text, request.url, yaml);\n    }\n\n    this.cache.set(url, parsed);\n    return parsed;\n  }\n\n  parseContent(text, url, yaml \u003d false) {\n    const ext \u003d url.split(\u0027?\u0027)[0].split(\u0027#\u0027)[0].split(\u0027.\u0027).pop().toLowerCase();\n    if (ext \u003d\u003d\u003d \u0027json\u0027) {\n      try {\n        return JSON.parse(text);\n      } catch (error) {\n        throw new Error(`Error parsing JSON in ${url}: ${error.message}`);\n      }\n    } else if (yaml \u0026\u0026 (ext \u003d\u003d\u003d \u0027yaml\u0027 || ext \u003d\u003d\u003d \u0027yml\u0027)) {\n      if (typeof jsyaml \u003d\u003d\u003d \u0027undefined\u0027) {\n        throw new Error(\n          `YAML parsing requested, but js-yaml is not loaded.  ` +\n          `Include \u003cscript src\u003d\"https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js\"\u003e\u003c/script\u003e`\n        );\n      }\n      try {\n        return jsyaml.load(text);\n      } catch (error) {\n        throw new Error(`Error parsing YAML in ${url}: ${error.message}`);\n      }\n    } else if (yaml) {\n      throw new Error(`Unsupported file type for YAML parsing: ${url}`);\n    } else {\n      throw new Error(`Unsupported file type, .json expected, got: ${url}`);\n    }\n  }\n\n  async resolveRefs(schema, baseUrl, seen \u003d new Set(), middleware) {\n    if (typeof schema !\u003d\u003d \u0027object\u0027 || schema \u003d\u003d\u003d null) {\n      return schema;\n    }\n\n    if (seen.has(schema)) {\n      return schema; // Prevent infinite recursion on circular refs\n    }\n    seen.add(schema);\n\n    if (Array.isArray(schema)) {\n      const resolvedArray \u003d [];\n      for (const item of schema) {\n        resolvedArray.push(await this.resolveRefs(item, baseUrl, new Set(seen), middleware));\n      }\n      return resolvedArray;\n    }\n\n    if (schema.$ref \u0026\u0026 typeof schema.$ref \u003d\u003d\u003d \u0027string\u0027) {\n      const [refUrl, refPointer] \u003d schema.$ref.split(\u0027#\u0027);\n      const fullRefUrl \u003d refUrl ? new URL(refUrl, baseUrl).href : baseUrl;\n      let resolvedSchema \u003d await this.fetchSchema(fullRefUrl, middleware, schema.$ref.endsWith(\".yaml\") || schema.$ref.endsWith(\".yml\"));\n\n      if (refPointer) {\n        resolvedSchema \u003d this.resolvePointer(resolvedSchema, refPointer);\n      }\n\n      if (Object.keys(schema).length \u003e 1) {\n        const cloned \u003d { ...resolvedSchema };\n        for (const key in schema) {\n          if (key !\u003d\u003d \u0027$ref\u0027) {\n            cloned[key] \u003d schema[key];\n          }\n        }\n         // recursive call with merged object\n        return this.resolveRefs(cloned, baseUrl, new Set(seen), middleware);\n      }\n\n      return this.resolveRefs(resolvedSchema, fullRefUrl, new Set(seen), middleware); // Recursively resolve\n    }\n\n    const resolvedObject \u003d {};\n    for (const key in schema) {\n      resolvedObject[key] \u003d await this.resolveRefs(schema[key], baseUrl, new Set(seen), middleware);\n    }\n    return resolvedObject;\n  }\n\n  resolvePointer(schema, pointer) {\n    if (!pointer) {\n      return schema;\n    }\n    const parts \u003d pointer.substring(1).split(\u0027/\u0027).map(part \u003d\u003e\n      part.replace(/~1/g, \u0027/\u0027).replace(/~0/g, \u0027~\u0027)\n    );\n    let current \u003d schema;\n    for (const part of parts) {\n      if (current \u0026\u0026 typeof current \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 part in current) {\n        current \u003d current[part];\n      } else {\n        throw new Error(`Invalid JSON pointer: ${pointer}`);\n      }\n    }\n    return current;\n  }\n\n  defaultMiddleware(request, response) {\n    // Default middleware:  Does nothing, just returns the original request and response\n    return [request, response];\n  }\n}\n\n// --- Example Usage ---\n\n// Basic usage (no middleware, no YAML):\n// const parser \u003d new JSONSchemaRefParser();\n// parser.dereference(\u0027my-schema.json\u0027)\n//  .then(schema \u003d\u003e console.log(\u0027Dereferenced:\u0027, schema))\n//  .catch(err \u003d\u003e console.error(\u0027Error:\u0027, err));\nasync function runExample() {\n    // Example with custom middleware (CORS proxy):\n    const corsProxyMiddleware \u003d (request, response) \u003d\u003e {\n      if (request \u0026\u0026 request.url \u0026\u0026 request.url.startsWith(\u0027http://example.com\u0027)) {  // Only proxy requests to example.com\n        const proxiedUrl \u003d `https://cors-anywhere.herokuapp.com/${request.url}`;\n        // Modify the request to use the proxy:\n        return [{ ...request, url: proxiedUrl }, response];\n      }\n      // Pass-through for other requests:\n      return [request, response];\n    };\n\n    const parserWithMiddleware \u003d new JSONSchemaRefParser();\n    try {\n      const schema \u003d await parserWithMiddleware.dereference(\u0027my-schema.json\u0027, { middleware: corsProxyMiddleware });\n      console.log(\u0027Dereferenced with middleware:\u0027, schema);\n    }\n    catch(err) {\n        console.error(err);\n    }\n\n    // Example with YAML support (requires js-yaml to be loaded):\n    const parserWithYAML \u003d new JSONSchemaRefParser();\n    try {\n        const schema \u003d await parserWithYAML.dereference(\u0027my-schema.yaml\u0027, { yaml: true });\n        console.log(\u0027Dereferenced YAML:\u0027, schema);\n    }\n    catch(err) {\n        console.error(err);\n    }\n}\n\n// In an HTML file, you would include:\n// \u003cscript src\u003d\"https://cdn.jsdelivr.net/npm/js-yaml@4/dist/js-yaml.min.js\"\u003e\u003c/script\u003e  \u003c-- Only if you need YAML\n// \u003cscript\u003e\n//   // ... (paste the JSONSchemaRefParser class code here) ...\n// \u003c/script\u003e\n\n// Run the example (you\u0027ll need to have a local server running to avoid CORS issues)\nrunExample();\n\n```\n\nKey changes and explanations in this revised implementation:\n\n*   **`JSONSchemaRefParser` Class:** Renamed the class to be more explicit about its JSON focus.\n*   **Optional YAML Support:**\n    *   The `dereference` and `fetchSchema` methods now accept an optional `options` object.\n    *   The `options` object can have a `yaml` property (defaulting to `false`).\n    *   The `parseContent` method checks for `yaml: true` *and* whether `jsyaml` is defined (globally).  If `yaml` is true but `jsyaml` is missing, it throws a helpful error message.  This makes YAML support truly optional.\n    *   Added a check to see if the $ref being dereferenced ends with `.yaml` or `.yml` and sets `yaml` to true.\n\n*   **Middleware:**\n    *   The `fetchSchema` method now *requires* a `middleware` function.\n    *   A `defaultMiddleware` is provided that simply returns the original request and response (a no-op).\n    *   The `middleware` function is called *twice*:\n        1.  **Before the request:**  It receives a `request` object (with `url` and `method` properties) and can modify it (e.g., change the URL, add headers). It returns a possibly modified `request` object.\n        2.  **After the response:** It receives the (possibly modified) `request` and the `fetch` `Response` object.  It can inspect the response (e.g., check status codes, headers) and modify it *before* it\u0027s processed. It returns a possibly modified `response` object.\n    * The middleware returns an array of `[request, response]`, where the `request` is the possibly modified request, and `response` is the possibly modified response, *or* a parsed object.\n*   **Error Handling:**  Uses standard `Error` objects with more descriptive messages. Includes error messages when JSON or YAML parsing fails.\n*   **`fetchSchema` Caching:**  The `fetchSchema` method still caches fetched schemas to avoid redundant network requests.\n*   **`resolveRefs` Recursion:** The `resolveRefs` method uses a `Set` called `seen` to detect and prevent infinite recursion when handling circular references.\n*   **Clearer Example Usage:**  The example code demonstrates:\n    *   Basic usage (no middleware).\n    *   Usage with a custom middleware (a CORS proxy example).\n    *   Usage with optional YAML support.\n* **Handles properties alongside $ref:** Handles the case where there are extra properties alongside `$ref` and merges them.\n* **Relative paths:** Supports relative paths using the `URL` constructor.\n* **baseUrl option:** Added a `baseUrl` option to the `dereference` method.\n\nThis revised implementation addresses all your requirements:\n\n*   **JSON-focused:**  Primarily designed for JSON Schema.\n*   **Optional YAML:**  YAML support is easily enabled/disabled and requires the user to explicitly load `js-yaml`.\n*   **Middleware:**  Provides a flexible middleware system for intercepting and modifying requests and responses.\n*   **Single Snippet:**  The code is a single, self-contained JavaScript class.\n*   **Relative Paths:** Correctly handles relative paths using web standards.\n*   **Browser-Native:**  Relies only on standard browser APIs (`fetch`, `URL`, `TextEncoder`, `TextDecoder`).\n\nThis provides a solid, browser-compatible JSON Schema dereferencing solution with the flexibility you need. Remember to run this code in a browser environment with a local server (e.g., using `python -m http.server`, `npx http-server`, or similar) to avoid Cross-Origin Resource Sharing (CORS) issues when fetching local files.\n",
      "role": "model",
      "finishReason": "STOP",
      "tokenCount": 3158
    }, {
      "text": "No YAML support please! No extra dependencies allowed! \nStart by sharing detailed working out then critically review your last attempt, and provide a full complete minimal implementation that meets all requirements. Try again.",
      "role": "user",
      "tokenCount": 41
    }, {
      "text": "Okay, let\u0027s eliminate YAML support completely and refine the solution further, focusing on a pure JSON Schema dereferencer with middleware, relative path support, and no external dependencies.\n\n**1. Detailed Working Out \u0026 Analysis (Second Revision)**\n\n*   **YAML Removal:** We\u0027ll remove all references to `js-yaml` and the `yaml` option. The `parseContent` function will only handle JSON parsing.\n\n*   **Middleware Refinement:** The middleware concept from the previous iteration is good, but we can simplify it slightly. Instead of returning an array `[request, response]`, we\u0027ll have the middleware return a *single* object that can contain *either* a modified `request` *or* a `parsed` value (or both). This makes the middleware\u0027s intent clearer: it can either modify the request *before* fetching or completely bypass fetching and provide a parsed result directly.\n\n*   **Error Handling:** We\u0027ll continue using standard `Error` objects, but we\u0027ll ensure the error messages are as informative as possible, including the URL of the file being processed.\n\n*   **Caching:** The caching mechanism in `fetchSchema` is essential for performance and avoiding infinite loops with circular references. We\u0027ll keep it.\n\n*   **`resolveRefs` Recursion:** The `seen` Set is crucial for preventing infinite recursion. We\u0027ll keep this as well.\n\n*   **`resolvePointer`:** This function correctly handles JSON Pointers, and we\u0027ll retain it.\n\n*   **Code Style:** We\u0027ll aim for clear, concise, and well-commented code.\n\n* **Properties alongside `$ref`:** Support properties alongside `$ref` and merge them.\n\n**2. Critical Review of the Previous Attempt**\n\nThe previous attempt was a significant improvement, but here are some areas for refinement:\n\n*   **Middleware Complexity:** The `[request, response]` return value from the middleware was slightly more complex than necessary. A single object with optional `request` and `parsed` properties is cleaner.\n*   **YAML Option:** Even though it was optional, the presence of YAML-related code added unnecessary complexity for a JSON-only parser.\n*   **Error Messages:** While improved, the error messages could be even more specific in some cases (e.g., when a JSON pointer is invalid).\n*   **Redundant `new Set(seen)`:**  In the recursive calls to `resolveRefs`, we were creating a *new* `Set` on each call.  This is inefficient. We should reuse the same `Set` instance.\n\n**3. Minimal Reimplementation (Final Version)**\n\n```javascript\nclass JSONSchemaRefParser {\n  constructor() {\n    this.cache \u003d new Map();\n  }\n\n  async dereference(schemaOrURL, options \u003d {}) {\n    const { middleware \u003d this.defaultMiddleware, baseUrl \u003d null } \u003d options;\n\n    const schema \u003d typeof schemaOrURL \u003d\u003d\u003d \u0027string\u0027 ?\n      await this.fetchSchema(schemaOrURL, middleware) :\n      schemaOrURL;\n\n      const resolvedBaseUrl \u003d baseUrl || (typeof schemaOrURL \u003d\u003d\u003d \u0027string\u0027 ? schemaOrURL : window.location.href);\n\n    return this.resolveRefs(schema, resolvedBaseUrl, new Set(), middleware);\n  }\n\n  async fetchSchema(url, middleware) {\n    if (this.cache.has(url)) {\n      return this.cache.get(url);\n    }\n\n    const initialRequest \u003d { url, method: \u0027GET\u0027 };\n    const middlewareResult \u003d await middleware(initialRequest);\n\n    if (middlewareResult \u0026\u0026 middlewareResult.parsed) {\n      // Middleware provided a parsed result, so bypass fetching\n      this.cache.set(url, middlewareResult.parsed);\n      return middlewareResult.parsed;\n    }\n\n    const request \u003d (middlewareResult \u0026\u0026 middlewareResult.request) || initialRequest;\n    const response \u003d await fetch(request.url, request);\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch ${request.url}: ${response.status} ${response.statusText}`);\n    }\n\n    const text \u003d await response.text();\n    const parsed \u003d this.parseContent(text, request.url);\n    this.cache.set(url, parsed);\n    return parsed;\n  }\n\n  parseContent(text, url) {\n    try {\n      return JSON.parse(text);\n    } catch (error) {\n      throw new Error(`Error parsing JSON in ${url}: ${error.message}`);\n    }\n  }\n\n  async resolveRefs(schema, baseUrl, seen, middleware) {\n    if (typeof schema !\u003d\u003d \u0027object\u0027 || schema \u003d\u003d\u003d null) {\n      return schema;\n    }\n\n    if (seen.has(schema)) {\n      return schema; // Prevent infinite recursion on circular refs\n    }\n    seen.add(schema);\n\n    if (Array.isArray(schema)) {\n      const resolvedArray \u003d [];\n      for (const item of schema) {\n        resolvedArray.push(await this.resolveRefs(item, baseUrl, seen, middleware));\n      }\n      return resolvedArray;\n    }\n\n    if (schema.$ref \u0026\u0026 typeof schema.$ref \u003d\u003d\u003d \u0027string\u0027) {\n      const [refUrl, refPointer] \u003d schema.$ref.split(\u0027#\u0027);\n      const fullRefUrl \u003d refUrl ? new URL(refUrl, baseUrl).href : baseUrl;\n      let resolvedSchema \u003d await this.fetchSchema(fullRefUrl, middleware);\n\n      if (refPointer) {\n        resolvedSchema \u003d this.resolvePointer(resolvedSchema, refPointer);\n      }\n\n      if (Object.keys(schema).length \u003e 1) {\n        const cloned \u003d { ...resolvedSchema };\n        for (const key in schema) {\n          if (key !\u003d\u003d \u0027$ref\u0027) {\n            cloned[key] \u003d schema[key];\n          }\n        }\n        return this.resolveRefs(cloned, baseUrl, seen, middleware); // resolve the merged object\n      }\n\n      return this.resolveRefs(resolvedSchema, fullRefUrl, seen, middleware); // Recursively resolve\n    }\n\n    const resolvedObject \u003d {};\n    for (const key in schema) {\n      resolvedObject[key] \u003d await this.resolveRefs(schema[key], baseUrl, seen, middleware);\n    }\n    return resolvedObject;\n  }\n\n  resolvePointer(schema, pointer) {\n    if (!pointer) {\n      return schema;\n    }\n    const parts \u003d pointer.substring(1).split(\u0027/\u0027).map(part \u003d\u003e\n      part.replace(/~1/g, \u0027/\u0027).replace(/~0/g, \u0027~\u0027)\n    );\n    let current \u003d schema;\n    for (const part of parts) {\n      if (current \u0026\u0026 typeof current \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 Object.hasOwn(current, part)) {\n        current \u003d current[part];\n      } else {\n        throw new Error(`Invalid JSON pointer \"${pointer}\" in schema ${JSON.stringify(schema)}`);\n      }\n    }\n    return current;\n  }\n\n  defaultMiddleware(request) {\n    // Default middleware: Does nothing, just returns the original request.\n    return { request };\n  }\n}\n\n// --- Example Usage ---\n\nasync function runExample() {\n    // Example with custom middleware (add a header):\n    const addHeaderMiddleware \u003d (request) \u003d\u003e {\n      const modifiedRequest \u003d {\n        ...request,\n        headers: {\n          ...request.headers,\n          \u0027X-Custom-Header\u0027: \u0027MyValue\u0027,\n        },\n      };\n      return { request: modifiedRequest };\n    };\n\n    const parserWithMiddleware \u003d new JSONSchemaRefParser();\n    try {\n        const schema \u003d await parserWithMiddleware.dereference(\u0027my-schema.json\u0027, { middleware: addHeaderMiddleware });\n        console.log(\u0027Dereferenced with middleware:\u0027, schema);\n    }\n    catch(err) {\n        console.error(err);\n    }\n\n    // Example with a proxy (bypass fetch entirely):\n    const proxyMiddleware \u003d (request) \u003d\u003e {\n        if(request.url.startsWith(\u0027http://example.com\u0027)) {\n            // Instead of fetching, return a pre-parsed object:\n            return { parsed: { data: \u0027Proxied data for \u0027 + request.url } };\n        }\n        return {request}; // Pass-through\n\n    }\n    const parserWithProxy \u003d new JSONSchemaRefParser();\n\n    try {\n        const schema2 \u003d await parserWithProxy.dereference(\u0027http://example.com/schema.json\u0027, { middleware: proxyMiddleware });\n        console.log(\u0027Dereferenced with proxy:\u0027, schema2);\n    }\n    catch(err) {\n        console.error(err);\n    }\n}\n\n// In an HTML file, you would include:\n// \u003cscript\u003e\n//   // ... (paste the JSONSchemaRefParser class code here) ...\n// \u003c/script\u003e\n\n// Run the example (you\u0027ll need to have a local server running to avoid CORS issues when fetching local files)\nrunExample();\n\n```\n\nKey improvements in this final version:\n\n*   **No YAML:**  Completely removed all YAML-related code.\n*   **Simplified Middleware:** The middleware now returns a single object with either a `request` property (for modifying the request) or a `parsed` property (for providing a pre-parsed result).\n*   **Improved Error Handling:** More specific error messages, especially for invalid JSON pointers.\n*   **Efficient Recursion:**  The `resolveRefs` function now reuses the same `seen` Set instance for all recursive calls, avoiding unnecessary object creation.\n*   **Clearer `fetchSchema` Logic:** The logic for handling the middleware result in `fetchSchema` is more explicit.\n*   **Concise Code:** The code is well-commented and uses modern JavaScript features (async/await, spread syntax).\n* **Handles properties alongside $ref:** Handles and merges properties alongside `$ref`.\n* **Relative paths:** Supports relative paths using the `URL` constructor.\n* **baseUrl option:** Added a `baseUrl` option to the `dereference` method.\n\nThis final version is a robust, browser-native, JSON-only schema dereferencer with a flexible middleware system, all in a single, self-contained code block with no external dependencies. It\u0027s ready to be used directly in a browser environment. The example usage demonstrates both adding a header via middleware and completely bypassing `fetch` using a proxy middleware. It also handles circular references and relative/absolute URLs correctly. This is a production-ready minimal implementation.\n",
      "role": "model",
      "finishReason": "STOP"
    }],
    "pendingInputs": [{
      "text": "",
      "role": "user"
    }]
  }
}